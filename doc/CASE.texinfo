@c\input texinfo @c -*-texinfo-*-
@c *********************************************************************
@c
@c  $Id: CASE.texinfo,v 1.3 1996/09/01 19:51:05 sevaldt Exp $
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online inforeader can parse
@c  the file hierachically.
@c
@c  Each time you add or change a node, you need to update the
@c  menus and forward/backward references. You can do this from
@c  emacs automatically by writing:
@c
@c  ESC-x texinfo-every-node-update
@c  ESC-x texinfo-all-menus-update
@c  ESC-x texinfo-master-menu
@c
@c In practice you can just type the first few letters and hit TAB
@c to write these long names.
@c
@c ***********************************************************************
@c %** start of header
@setfilename case.info
@settitle Cellular automaton

@setchapternewpage odd
@c %** end of header

@include version.texi
@finalout

@titlepage
@title CASE
@subtitle Cellular Automata Simulation Environment
@subtitle Edition @value{EDITION}
@subtitle For version @value{VERSION}, @value{UPDATED}

@iftex
@author M. Burgess, J.A. Mikkelsen and T.E. Sevaldrud
@author Centre of Science and Technology, Oslo College

@ifinfo
@author M. Burgess J.A. Mikkelsen and T.E. Sevaldrud
@author Centre of Science and Technology, Oslo College
@end iftex
@end ifinfo

@c @smallbook

@page
@center @b{Abstract}
@cite{@i{Computations based on regular arrays of cells may be used to study
many scientific phenomena. We present a generic, user-configurable
visualization system for so-called @emph{cellular automata}, which can
be used to build models for such computations and display the results
using X11 windows. The difficulties of graphical programming are
hidden from the user by an object oriented `black box' interface,
which allows scientists to concentrate on their models rather than on
complex technical programming.  Our environment allows parallel
simulations, large grids, zooming, and can handle both scalar and
vector fields. Example toy-models which illustrate our general system
include Conway's Game of Life and the X-Y model of electron spin.}}

@vskip 0pt plus 1filll
@ifinfo
Copyright @copyright{} 1996 Mark Burgess, J.A. Mikkelsen and T.E. Sevaldrud

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@end ifinfo
Copyright @copyright{} 1996 Mark Burgess, J.A. Mikkelsen and T.E. Sevaldrud

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@end titlepage

@iftex
@headings off
@everyheading @special{psfile=scitech.ps hoffset=-180 voffset=-206 hscale=53 vscale=53} @| @thischapter  @| @thispage
@end iftex


@c *************************** File begins here ************************

@ifinfo
@node Top, Foreword, (dir), (dir)
@top Cell

@end ifinfo


@c **********************************************************************
@c INTRO
@c **********************************************************************

@menu
* Foreword::                    
* How to read this manual::     
* Overview::                    
* Getting Started::             
* Object structure::            
* Game of life::                
* Requesters::                  
* The CAApp object::            
* The CAModel object::          
* The CAEnviron object::        
* The CACell object::           
* The CAProperty object::       
* The CAVisual object::         
* The CASymbol object::         
* The Req object::              
* Making Menus::                
* Toolkit functions and classes::  
* X2DviewWidgetClass::          
* bibliography::                
* Variable and function Index::  

 --- The Detailed Node Listing ---

How to read this manual

* Overview::                    
* Object structure::            
* bibliography::                
* Variable and function Index::  
* Concept Index::               


Overview

* What is a cellular automaton?::  
* A configurable tool::         
* Key concepts::                the solution
* CASE File Tree::              

Key Concepts

* Object orientation::          
* X windows and widgets::       
* Events and Callbacks::        

Object structure

* Object Relations::            
* CAApp::                       
* CAModel::                     
* CAVisual::                    
* CACell::                      
* CAEnviron::                   

CAApp

* CAApp Features::              

CAModel

* CAModel Features::            

CAVisual

* CAVisual Features::           

CACell

* CACell Features::             

CAEnviron

* CAEnviron Features::          

{Introduction}

* Making the LifeCell object::  
* Making The GameOfLife object::  
* Making GoLApp::               
* Making main()::               

Requesters

* The cell requester::          
* The environ requester::       
* The color requester::         
* File Requester::              

The color requester

* Color Requester Introduction ::  
* Col Req Programming Interface::  
* Col Req Public member Functions::  

The File Requester object

* File Requester Introduction::  
* Fil Req Programming Interface::  
* Fil Req Public member functions::  

Programming Interface

* File requester tags::         

File requester tags

* Public member functions::     

The CAApp object

* Introduction::                
* Functions::                   

The CAModel object

* CAModel Introduction::        
* CAModel Functions::           

Functions

* CAModel Public member functions::  
* Protected member functions::  

The CAEnviron object

* CAEnviron Introduction::      
* CAEnviron Functions::         

Introduction 

* Functions::                   

Provided subclasses

* The CAGrid object::           

The CACell object

* CACell Introduction::         
* CACell Functions::            

The CAProperty object

* CAProperty Introduction::     
* Provided subclasses::         
* CADouble Functions::          

Provided subclasses

* CADouble::                    
* CABoolean::                   

The CAVisual object

* GOL Introduction::            
* The drawing area::            
* The text area::               
* The CAVisual menus::          
* CAVisual Functions::          

The drawing area

* The coordinate system::       
* The color palette::           
* Double-buffering::            
* The drawing area tags::       

The coordinate system

* Zooming::                     

The text area

* The text area tags::          

Functions

* CAVisual functions::          
* CATextVisual functions::      

The CASymbol object

* CASymbol Introduction::       
* CASymbol Programming interface::  

The Req object

* Req Introduction::            
* Req A short tutorial::        
* Adding Callbacks::            
* Reading the requester::       
* Pop up the requester::        
* Use extra control widgets::   

A short tutorial

* Initializing::                
* Adding groups::               
* Adding widgets::              

Adding widgets

* Adding Callbacks::            

Making Menus

* Menus Introduction::          
* Menus A short tutorial::      
* Example Functions::           

A short tutorial

* Create the menubar::          
* Add menus::                   
* Fill in the menu items::      
* Complete example::            

Complete example

* Functions::                   

Toolkit functions and classes

* The polygon object::          
* The index_array object::      
* The AddBitmapToWidget function::  
* The taglist interface::       

The polygon object

* Toolkit Programming interface::  

The taglist interface

* Taglist Functions::           

X2DviewWidgetClass

* X2DviewWidgetClass Introduction::  
* Resources::                   

Introduction

* Compatibility::               
* X2DviewWidgetClass Features::  
* Availability::                
* Bugs (undocumented features)::  

Resources

* Custom resources explained::  

Custom resources explained

* x_min::                       
* def_x_min::                   
* pixx::                        
* zBoxLineStyle::               
* zBoxLineWidth::               
* zBoxForeground::              
* viewportChanged::             
* click::                       
* rtClick::                     
@end menu

@node Foreword, How to read this manual, Top, Top
@unnumbered Foreword

This document describes the CASE (Cellular Automata Simulation
Environment) programming library. This project started as a graduation
project at Oslo College, Dept of Engineering under the supervision
of Mark Burgess and is now being continued by a small group from
the College and the University of Oslo. It is hoped that this tool
will allow scientists of all kinds to make
efficient and informative simulations of two dimensional and
layered-three-dimensional systems. We encourage
you to make your own models and keep us informed of bugs and
improvements. The CASE project may be  addressed by E-mail
@smallexample

case@@iu.hioslo.no

@end smallexample
@noindent
Latest changes and information may be obtained online from
@smallexample

http://www.iu.hioslo.no/~cell

@end smallexample

Oslo, August 1996

@c **********************************************************************
@c CHAPTER
@c **********************************************************************

@node How to read this manual, Overview, Foreword, Top
@unnumbered How to read this manual

This manual is intended to have two purposes: A tutorial for learning
how to set up a Cellular Automaton model, and secondly as reference
for the programmer. Chapter ?? is a run-through of making a model based
on "Conways game of life", and should hopefully illustrate how the
programming interface works, and get you up and going. Chapters ?? to ??
contain detailed descriptions of each major object in the CASE
programming library. Each of these chapters have an introductory section
which you probably should read to understand the principles behind the
objects. Each of these chapters also have a function reference chapter,
which you could skip upon first time reading and rather use them as
reference later. The function descriptions are written in a Unix
'man'-like layout for easier reading.

In the back of the manual you will find a function
index, which should make it easier to find the necessary
fuctions. Functions in this index are referenced in C++ style with
@code{class::function} notation, where @code{class} is the class in
which @code{function} is belongs. Some of the function definitions 
have a paragraph called @emph{Inheritance}. This paragraph describes if
and how the method or class object should be inherited by subclasses.

Throughout this manual all variables and functions as well as code
extracts will be typeset in @code{typewriter} font. All class object
methods are written in the pattern @code{class::function()} unless the
method is referenced in such a context that it is obvious which object
it is associated with.





@c **********************************************************************
@c CHAPTER
@c **********************************************************************

@menu
* Overview::                    
* Object structure::            
* bibliography::                
* Variable and function Index::  
* Concept Index::               

@end menu

@node Overview, Getting Started, How to read this manual, Top
@chapter Overview


@menu
* What is a cellular automaton?::  
* A configurable tool::         
* Key concepts::                the solution
* CASE File Tree::              
@end menu

@c -----------------------------------------------------------------------
@c SECTION - What is a cellular automaton
@c -----------------------------------------------------------------------

@node What is a cellular automaton?, A configurable tool, Overview, Overview
@section What is a cellular automaton?


A cellular automaton is a simulation engine in which
cells, arranged in a symmetrical pattern, interact with their
neighbours according to well-defined rules.

Cellular automata have traditionally been used by
physicists and biologists for studying such diverse
problems as

@itemize @bullet
@item
development of cellular life,
@item   
mixing of two fluids,
@item   
penetration of porous media (e.g. oil in rock),
@item   
magnetic spin systems (recording-media technology)[Dahlberg95],
@end itemize

@noindent
but increasingly, they are being used as general
`analogue computers' by engineers and statisticians
for the modelling of

@itemize @bullet
@item 
traffic flow at junctions[Schadscheider95],
@item 
network analysis,
@item
diffusion of gases and liquids,
@item 
spread of rust and other chemical interfaces.
@end itemize

The aim of this project is to create an integrated framework for
creating generalized cellular automata using the best, standardized
technology of the day. Since such simulations have been in the hands of
physicists for many years, most simulations have been hacked out in
Fortran, which leaves much to be desired. We are well aware that a
robust approach, developed for extensibility can only be achieved by the
use of a standardized, structured language. The natural choice (the only
freely available object oriented language with an interface to graphics)
is C++. Recently, a few projects have siezed upon Sun Microsystems' new
language Java in order to create visualization simulations[Argus,Virtual
Lab]. A disadvantage with Java is that it is presently much slower than
C++, though this may change in the future.

The need for a generalized cellular automaton which users can modify
themselves in a modular way is clear: as of today the only possibility
for making such simulations is to use a package such as IDL which costs
several thousand dollars, or to program one's own. The technical
knowledge required to deal with graphics and visualization is beyond
what most scientists are willing to learn in order to solve their
problems. We aim therefore to provide a tool which is both more
accessible and better suited to the problem of cellular simulations.

Recently it has been demonstrated that there is a direct connection
between a cellular automaton and integrable non-linear wave equations,
such as those used to describe solitons and a wide range of
phenomena in physics, chemistry, biology and computer science.
The cellular automaton connection makes the prospect of modelling
the @math{N} soliton problem numerically realistic.

@c -------------------------------------------------------------------------------
@c SECTION - a configurable tool
@c -------------------------------------------------------------------------------

@node A configurable tool, Key concepts, What is a cellular automaton?, Overview
@section A configurable tool

@cindex Requirements
@cindex Specifications

Our realization of the automaton falls in to roughly two parts: the
first is a classical finite state machine, in the tradition of von
Neumann. A finite state machine is an abstract system which can exist in
any one of a discrete set of states or conditions.  At any time, the
`state of the system' is characterized by the state (or value) of all of
the cells collectively. The system evolves in time by applying a
well-defined rule to each cell iteratively. Well known examples of such
automata include the Game of Life.

The second part is a visualization system or presentation manager which
can display the state of the simulation in a variety of
user-configurable ways. This presentation manager is our main focus in
this project, since this is the part which is most difficult for
non-specialists to implement themselves.  The details of
the finite state machine are mainly dictated by specific uses of the
cellular automaton and these are not our immmediate concern. On the
other hand, we intend to provide a structured framework for the state
machine so that the technical details of the visualization system are as
far as possible transparent to the end user, and build a framework
which can be used and built upon to make genuinely useful simulations.

A given cellular simulation is characterized by the following
parameters:
@table @bullet
@item Choice of symmetry
The way in which the cells are arranged in space, reflects the underlying
nature of the physical system. Various possibilities suggest themselves
in nature: square lattices, triangular and hexagonal lattices. In
many crystalline materials it is common to find a superposition of two
types of lattice, for instance, body centres cubic lattices or
crystals with interstitial atoms. A generalized automaton must therefore
allow for the possibility of a range of different underlying symmetries.
@item Choice of neighbour interaction
The way in which cells interact with other cells is what determines the
dyanamics of the simulation. Typically, each cell is influenced only by
its nearest neighbours, but this limitation might easily be rescinded
in more complex simulations. In our implementation of the cell update
mechanism, we place no restrictions on the rules by which cells change
their state.
@item Multiple states
The state of a cell might represent a variety of different physical
situations. In a simple model of cellular life, only a binary state
is required: each cell is either alive or dead. The modelling of
electron spin in a two-dimensional lattices, on the other hand, requires
a vector quanity: an arrow indicating the direction of spin. In addition
to the spin direction, we might want to indicate the local temperature
of the system by using a different color. We must therefore
allow the most general possible scheme of visualization for the
parameters which determine the model.
@end table

Our specifications are based on the following list of wishes.

@itemize @bullet

 @item 
High pedagogical standards of coding are required. We aim to write
clear, state of the art code which will be understandable to intelligent
non-specialists! The end users of our system are likely to be physicists
and other scientists with considerable programming skills, but with
little or no knowledge of the complexities of graphical window based
programming techniques.

 @item We required an n-state automaton based on a lattice. The symmetry
of the lattice should be configurable (square, hexagonal, triangular,
etc).  The method of illustrating that a site is in the n-th state
should be user-configurable (choice of different colors, symbols, or
arrow orientation).

 @item 
Choice of color palette should be configurable.

 @item The system size and boundary conditions: periodic (wrap-around)
or non-periodic boundary conditions are desirable.

 @item 
The number of widgets and windows should be kept to a minimum
to make the tool as simple as possible to understand.

 @item 
Resize and zoom onto a particular area of the lattice.

 @item 
Freezing and continuation of a simulation should be possible at any time.
It should also be possible to save the state of the system for a later
time, so that the simulation can be restarted. 

 @item 
It should be possible to edit the states of any site either at 
the start of the simulation or during a "freeze".

 @item 
We wish to avoid X resource files if possible. These are files which
configure X11's object oriented interface.  X should hard code sensible
default resources, or have a "preferences"
   editor, since default files can easily get lost.

 @item 
Hard copy snapshots of the simulation should be obtainable in
latex/pictex format or postscript. All documentation is assumed to be in
a variant of Tex, since this is the standard in the scientific
community.


@end itemize


@c -------------------------------------------------------------------------------
@c SECTION - Key Concepts
@c -------------------------------------------------------------------------------

@node Key concepts, CASE File Tree, A configurable tool, Overview
@section Key Concepts

In this section we present an overview of the key concepts on which
our visualization system is based.

@menu
* Object orientation::          
* X windows and widgets::       
* Events and Callbacks::        
@end menu


@c .....................................................
@c SUBSECTION
@c .....................................................

@node Object orientation, X windows and widgets, Key concepts, Key concepts
@subsection Object orientation

Object orientation is a method of structuring ideas. It has been
siezed upon in the computing world as a natural outgrowth of
top-down or hierachical methods, since it provides a systematic method
of hierachy policing.
 
Object orientation is a way of structuring data and function calls by
classifying them according to a rigorous logical scheme. The aim of this
classification is to provide a check on the logical structure of the
program. Logically separate parts of a program are kept physically
separate by controls which are built into the language.
Variables which exist inside an object cannot be accessed
in an ad hoc manner by functions which belong to a different logical
class, but information can be sent down a `sub-hierachy' or sub-class
in a controlled way by a methodlogy called @emph{inheritance}.

Inheritance is a mechanism for providing extra compiler checks in
situations where one traditionally would have used global variables.
Global variables can be read and written to by any part of a program.
This allows programming styles in which data pass from function to
function `invisibly'. Sometimes such transparent communication is
desirable, but it always requires considerable caution, since it is
invisible to the compiler and thus no error messages can be diagnosed
automatically. Such practices tend to make programs less robust, since
they rely on the competence and presence of mind of the programmer,
rather than submitting themselves freely to policing by the compiler.

In inheritance, one generalizes the possibilites of scope
from being just local and global, to include @emph{objects}.
An object is a self contained environment. Inside an
object one can define functions and variables. Variables
can be global within a particular object, but not be
accessible outside that object. The global object is then
inherited by sub-objects which belong to the hierachy
which is derived with that particular object at its
uppermost level, but cannot be allowed to leak out
without specific permission.

C++ is a practical implementation of object oriented
technology based on the popular and efficient C programming
language. While adopting the compiler controls of other
object languages, C++ maintains the runtime efficiency of
C. A negative side of C++ is that the language involves
a considerable amount of syntax. Forunately this is not
too difficult to learn.

@c .....................................................
@c SUBSECTION
@c .....................................................

@node X windows and widgets, Events and Callbacks, Object orientation, Key concepts
@subsection X windows and widgets

As for a graphical interface, it is natural to choose MIT's
X window system which is already a de facto standard in the
UNIX world and has been ported for use under Windows NT.
@footnote{In all likelihood, X windows will survive as the standard
windowing system on all systems, in some form or other, with Windows and Motif and
MacIntosh windows running as client libraries to X. This is because
X11 is the only windowing system which can run across a network.}
The X window system is itself an object oriented environment.
Each window or graphical object is an `object' in the sense of
the previous section. Sub-objects inherit the properties of
their parents or can override them.

To simplify slightly,
an X11 program is charcterized by two kinds of object: windows and
widgets. A widget is any kind of graphical interface object which
can exist within a window. Buttons, scrollbars, file-requesters etc
are all examples of widgets. Widgets are constructed from sub-widgets
hierachically, or more correctly, in an object oriented fashion.
A file-requester might contain text-widgets as well as buttons for example.

The abililty to define new widgets from existsing ones allows us to hide
many technical details of our program within such widget objects, and
therefore simplify the programming interface as much as possible for
non-specialists.  Since the X11 system is widely regarded as an
extremely difficult system, even for specialists, this is clearly an
advantage to the scientific community. We do not intend to describe
the X window system in detail here, but refer to the extensive documentation
[X windows].

@c .....................................................
@c SUBSECTION
@c .....................................................

@node Events and Callbacks,  , X windows and widgets, Key concepts
@subsection Events and Callbacks

A graphical user interface works in a fundamentally different
way to a traditional question-answer driven interactive program.
The user is presented with an image which consists of many objects
which may be clicked upon or moved with the mouse pointer and
is encouraged to click on any of these at any time. In this
scenario, it is not the program which steers the user, by prompting
questions and receiving answers, but the user who steers the program.
The program must then respond to the random wishes of the user's
clicks by @emph{reacting} with an appropriate action.

A system like the one described above is called an @emph{event-driven}
program and is handled by a so-called @emph{event-loop} or @emph{reactor}.
Because the user might click on a graphical object at any time, a
program must be ready to receive input at any time and service that
input quickly. This is achieved by centering all such interactive
programs around a user-interface. 

Each time the user clicks on a graphical object (a button or menu item),
a hardware signal is sent from the mouse to the system's I/O port. This
signal is intercepted by the X windows system and the coordinates of the
mouse pointer are used to decode which object was clicked on. The X window
system then generates a @emph{software signal} or @emph{event message}
which is placed in a queue for processing. It is the job of an X program
to process this event queue fast enough so that the events do not
build up out of control.

@smallexample

while (XGetNextEvent())
   @{
   case ButtonPress:
                      @var{callback()};

   @var{other events}
   @}

@end smallexample

The X windows system provides a programming interface to these software
messages by allowing graphical objects to receive various classes of
message. For each class of message, on each instance of an object
(such as a button or menu), the user supplies a function which will be
called by X when that message is received. An additional level of
abtraction in this reactor based system allows the event loop to be
hidden in a library function. This abstraction is the @emph{callback}.

A @emph{callback} is a function which is called by the X window system
each time a graphical object receives a message. When setting up a
graphical user interface, such a callback function is @emph{registered}
with a graphical object (menu or button etc.). The system is therefore
told what function it should call, when such a message is received, and
what parameters it should send to that function. Callback functions
should return quickly so that the event loop does not fill up with
events. By registering these functions, one builds up a custom software
description of how an X application should behave to different external
stimuli.  In addition to registering callbacks, user programs can
register other functions which are to be performed at regular intervals
or times, such as functions to update the display, or to increment a
timer counter.

X callback functions are normally registered by providing a pointer
to function together with a pointer to a composite data object
which contains the arguments. In C++ this presents a problem for
class members because the member function needs to be connected with an
object-instantitation. This is solved by declaring the member function static,
and passing a pointer to the object as client data.

@smallexample
static void Req::OK(Widget w, XtPointer data, XtPointer garbage)
@{
 Req *req = (Req *) data;
 Req->foo();
@}
@end smallexample

@c -------------------------------------------------------------------------------
@c SECTION 
@c -------------------------------------------------------------------------------

@node CASE File Tree,  , Key concepts, Overview
@section CASE File Tree

In the main directory of the CASE file tree, you will find four
directories.

@table @file

@item bin
This directory contains miscellaneous executable utilities used in
creating CASE.

@item doc
The directory contains the texinfo documentation for CASE. You are reading
it!

@item lib
The directory contains two subdirectories @file{case} and @file{x2dview}
which, in turn, contain the code for the library functions on which the
CASE toolkit is based. You should not need to edit any of these files
(unless you find bugs, in which case you should inform the CASE project).

@item models
This directory contains example applications. This is where you build
your own models, unless you choose to install this directory in a
different place. 
@end table

We have not provided a `make install' option in the Makefiles for CASE.
This is because it is not thought of as being system software, and so
standard installation directories would not seem to be the correct place
for this package. 
To install CASE so that you can use it, you need the following files
installed in a place where the system linker can find them:

@example

lib/case/libCA.a
lib/x2dview/libx2dview.a

@end example
In other words you environment variable @code{LD_LIBRARY_PATH}
must include a directory where these files reside. Alternatively, you
can add the path to the Makefile with the @code{-L} option.

Until we have decided on an appropriate installation procedure, we suggest
that you do the following when building CASE.

@itemize @bullet


@item
Copy the libraries to a suitable directory.

@item
Copy the models subdirectory to the place where you would like to begin
your development. Edit the Makefile which the configure program generated
so that it works with your particular setup.

@item
Edit the Makefile to include any files which you add.

@item
Run @kbd{make} to build CASE each time you make a change.

@end itemize
@noindent
If you wish, you don't @emph{have} to move anything in the CASE file-tree,
but if you don't, you will have a more complicated time upgrading to newer
versions of the software later, because your own edits will be mixed up
with the distributed files.


@c **********************************************************************
@c CHAPTER
@c **********************************************************************

@node Getting Started, Object structure, Overview, Top
@chapter Getting Started

This aim of this chapter is to get you going as quickly as possible
by providing a step by step recipe for creating a simple cellular
automaton. In later chapters, we shall discuss the example automata
in detail.


@c **********************************************************************
@c CHAPTER - Object Structure
@c **********************************************************************

@node Object structure, Game of life, Getting Started, Top
@chapter Object structure

The CASE programming library largely consists of the following 7 class objects.

@itemize @bullet
  @item CAApp 
  @item CAModel
  @item CAVisual
  @item CACell
  @item CAEnviron
  @item CAProperty
  @item CASymbol
@end itemize

@menu
* Object Relations::            
* CAApp::                       
* CAModel::                     
* CAVisual::                    
* CACell::                      
* CAEnviron::                   
@end menu

@node Object Relations, CAApp, Object structure, Object structure
@section Object relations
The objects are related to each other in ``has-relations'' as
described in the figure below.

@iftex
@sp 18
@special{psfile=ERDiagram2.eps vscale=50 hscale=50 hoffset=70 voffset=9}
@end iftex

@node CAApp, CAModel, Object Relations, Object structure
@section CAApp
This is supposed to be the main class in the hierarchy. It will be
used to control the application in various vays, e.g starting and
stopping simulations, opening new frames, etc. 

@menu
* CAApp Features::              
@end menu

@node CAApp Features,  , CAApp, CAApp
@subsection Features 
@enumerate
  @item Is able to control several different models, and run their
        simulations synchronously.

  @item Is able to run simulations of @emph{one} model in
        several different windows. 

  @item Has responsibility for scheduling all running simulations.

  @item can be modified through inheritance.
@end enumerate

@node CAModel, CAVisual, CAApp, Object structure
@section CAModel
This object class is the "heart" of the simulation system. It is
responsible for updating the simulation of the Cellular Automaton
according to a given set of rules. These rules must be hardcoded in
the object, but this object should make it easy for the user to make new
simulations by defining a new model class as a child of @code{CAModel}.

@menu
* CAModel Features::            
@end menu

@node CAModel Features,  , CAModel, CAModel
@subsection Features

@enumerate 
  @item Contains all rules for updating the simulation.

  @item Is able to control @code{CACell}, @code{CAEnviron} and
        @code{CAVisual}. (Has access to their public properties).

  @item Is able to distribute function calls between the objects
        in (2).

  @item The object class is designed to be modified through inheritance.
@end enumerate

@node CAVisual, CACell, CAModel, Object structure
@section CAVisual
This object is responsible all drawing and text output in the main
window(s). Specifically, drawing of cells and grid structure
(@code{CAEnviron}). It is also responsible for handling the
widgets of the main window of each simulation.

@menu
* CAVisual Features::           
@end menu

@node CAVisual Features,  , CAVisual, CAVisual
@subsection Features
@enumerate 
  @item Provides an interface for various drawing operations in a
        drawing window.

  @item Provides an interface for outputting formatted text in a text window.

  @item Provides customizable menus.
@end enumerate

@node CACell, CAEnviron, CAVisual, Object structure
@section CACell
This object is the ``elementary particle'' @footnote{This is not
entirely true, it has some ``quark objects'' as well@code{:-)}} of the
simulation. Each @code{CACell} has a set of properties, which are changing in
various ways during the simulation. These properties can be modified
interactively during simulation (via requesters).

@menu
* CACell Features::             
@end menu

@node CACell Features,  , CACell, CACell
@subsection Features
@enumerate
  @item Is able to set up a requester via interaction with @code{CAProperty}.

  @item Is able to manipulate property values according to the rules
provided by CAModel.
@end enumerate

@node CAEnviron,  , CACell, Object structure
@section CAEnviron
This object defines the pattern of the cells in a simulation. This
pattern may be square, hexagonal, triangular, etc. And it is even
possible to make a ``floating'' pattern, i.e. no fixed positions for the
cells. The CASE library currently only provides the fixed grid class and
its derivatives. It should be straight forward to extend this with
support for ''floating pattern''.

@menu
* CAEnviron Features::          
@end menu

@node CAEnviron Features,  , CAEnviron, CAEnviron
@subsection Features
@enumerate
   @item Is able to determine the coordinates of a cell.

   @item Is able to locate neighbouring cells of a given cell.

   @item Provides dimension and geomtry for the grids.

   @item Has at least one traversal routine. 
@end enumerate
@c **********************************************************************
@c CHAPTER
@c **********************************************************************
@node Game of life, Requesters, Object structure, Top
@chapter Game of life

@section {Introduction}
This chapter will step by step create an application using CASE. We
chose the Game of Life application provided by CASE, because though it
is a simple model it uses many of the features provided by CASE.

When you are creating a application using CASE, you must first inherit
@code{CACell}, @code{CAModel} and @code{CAApp} then make @code{main}.
We have chosen the folowing names for our subclasses:
@itemize
@item GoLCell (subclass of CACell)
@item GameOfLife (subclass of CAModel)
@item GoLApp (subclass of CAApp)
@end itemize

@menu
* Making the LifeCell object::  
* Making The GameOfLife object::  
* Making GoLApp::               
* Making main()::               
@end menu

@node Making the LifeCell object, Making The GameOfLife object, Game of life, Game of life
@section Making the LifeCell object

The first you must do when making a subclass of @code{CACell} is to
choose which subclasses of @code{CAProperty} to use. In this case
@code{CABoolean} is the natural choise, because it is the only @emph{two
state} property provided. 

Create the header file @file{LifeCell.h} and the source file
@file{LifeCell.C}. Choose "alive" as the name of the property, and
add two functions to the @code{LifeCell}, @code{SetAlive()} and
@code{Alive()}. @code{SetAlive()} should a @code{Boolean()} as parametes, and
return nothing, this function is used to set the cell either dead or
alive. @code{Alive()} takes no parameters and returns @code{alive}.

@noindent
The header file should now be like this:
@smallexample
#include <CAReq.h>
#include <CAProperty.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <CACell.h>

class LifeCell : public CACell
@{

public:
   LifeCell();
   virtual ~LifeCell();
   Boolean Alive();
   void SetAlive(Boolean new_value);
   
protected:
   CABoolean alive;
private:
@};
@end smallexample

Let the constructor and destructor be empty functions, it is a good
habit to make the functions anyway. Now you cal implement @code{Alive()} and
@code{SetAlive}. The sourcefile shoud now look like this

@smallexample
LifeCell::LifeCell()
@{
@}

LifeCell::~LifeCell()
@{
@}

Boolean LifeCell::Alive()
@{
 return(alive.GetValue());
@}

void LifeCell::SetAlive(Boolean new_value)
@{
 alive.SetValue(new_value);
@}
@end smallexample

The functions controlling the @emph{cell requester} is declared abstract
in @code{CACell}, they must therefore be inherited. @xref{The cell
requester}. They are very simple to implement, in this class they will
only be one line each, calling the approppriate function of @code{alive}.

Each property must have a referance name when they are using
requesters. @xref{The Req object}. The referance name is implemented as
string that should be hardcoded in your subclass of @code{CACell}. This
name will also be used in the requester as identification. In this case
the referamce name will used as a label on the
button. @xref{CABoolean}. 

@noindent 
Implement the functions like this:
@smallexample
void LifeCell::SetupRequester(Req *requester)
@{
 alive.InitWidgets(requester, "Alive");
@}

void LifeCell::ReadWidgets(Req *requester)
@{
 alive.ReadWidgets(requester, "Alive");
@}

void LifeCell::UpdateWidgetValue(Req *requester)
@{
 alive.UpdateWidgetValue(requester, "Alive");
@}
@end smallexample

You must also update the header file with the three new functions. The
class definition should now look lik this:
@smallexample
class LifeCell : public CACell
@{

public:
   LifeCell();
   virtual ~LifeCell();
   virtual void SetupRequester(Req *requester);
   virtual void ReadWidgets(Req *requester);
   virtual void UpdateWidgetValue(Req *requester);
   Boolean Alive();
   void SetAlive(Boolean new_value);
   
protected:
   CABoolean alive;
private:
@};
@end smallexample

@node Making The GameOfLife object, Making GoLApp, Making the LifeCell object, Game of life
@section Making The GameOfLife object

First you must create the header file and source file for this
object. Then you must choose how you want the cells visualized, we chose
as an ellipse, and thus the @code{CAColoredEllipseSymbol} class.
 
Implement the header file like this:
@smallexample
#include <CAVisual.h>
#include <CAEnviron.h>
#include <GoLCell.h>
#include <CASymbol.h>
#include <CAModel.h>


class GameOfLife : public CAModel
{
public:
   GameOfLife(Widget new_parent);
   ~GameOfLife();
protected:
   CAColoredEllipse *symbol;
   
private:
};
@end smallexample

When implementing the constructor you must make some choices about the
window. @xref{The CAVisual object}. First you must decide if you want
text or just graphics in the window. We wanted to use text and therefore
we used @code{CATextVisual} instead of @code{CAVisual}. The tags used to
initialize the @code{CATextVisual}  will not be discussed here.


The next you must do is to create a grid, @code{CARectangularGrid} is
the natural choice. The constructor will now look like this:
@smallexample
 CAGrid *grid;
 visual = new CATextVisual(this,
			   VIS_Height, 500,
			   VIS_Width, 500,
			   VIS_Fontname, "Times",
			   VIS_Fontsize, 12,
			   VIS_TextLines, 10,
			   TAG_DONE);
 environ = grid = new CARectangularGrid;
 symbol = new CAColoredEllipseSymbol(visual, environ);
@end smallexample

The reson why you must make a @code{CAGrid} pointer is that you must now
set some specify how many rows and columns the grid should use. To do
this you must call @code{SetRowsCols()}. This is a function
defined in @code{CAGrid}, that takes to integers as parmeters. We wanted
a grid with 16 rows and 15 columns, you may use other numbers if you
like. Then you have to give the grid the dimensions of the coorinate
system, this is done by calling @code{SyncVievport}. The constructor will now look like this:

@smallexample
 CAGrid *grid;
 visual = new CATextVisual(this,
			   VIS_Height, 500,
			   VIS_Width, 500,
			   VIS_Fontname, "Times",
			   VIS_Fontsize, 12,
			   VIS_TextLines, 10,
			   TAG_DONE);
 environ = grid = new CARectangularGrid;
 symbol = new CAColoredEllipseSymbol(visual, environ);
 
 grid->SetRowsCols(16, 15); 
 environ->SyncViewport(visual);
@end smallexample

The only thing left before popping up the window is to allocate the
cells, this is done by calling @code{AllocateCells}. This function takes
the number of cells to allocate as parameter. We know that in a
rectangular grid this will be rows*cols, but this might not be true in
other grids. The only way of getting the right number is to call
@code{GAGrid::GetNumberOfCells}. The constructor now looks like this:
@smallexample
 CAGrid *grid;
 visual = new CATextVisual(this,
			   VIS_Height, 500,
			   VIS_Width, 500,
			   VIS_Fontname, "Times",
			   VIS_Fontsize, 12,
			   VIS_TextLines, 10,
			   TAG_DONE);
 environ = grid = new CARectangularGrid;
 symbol = new CAColoredEllipseSymbol(visual, environ);
 
 grid->SetRowsCols(16, 15); 
 environ->SyncViewport(visual);
 AllocateCells(grid->GetNumberOfCells());
@end smallexample

The last the constructor should do is to allocate colors, we wanted
white background, black foreground and red cells. @xref{The color
palette}. The constructor now looks like this:
@smallexample
 CAGrid *grid;
 visual = new CATextVisual(this,
			   VIS_Height, 500,
			   VIS_Width, 500,
			   VIS_Fontname, "Times",
			   VIS_Fontsize, 12,
			   VIS_TextLines, 10,
			   TAG_DONE);
 environ = grid = new CARectangularGrid;
 symbol = new CAColoredEllipseSymbol(visual, environ);
 
 grid->SetRowsCols(16, 15); 
 environ->SyncViewport(visual);
 AllocateCells(grid->GetNumberOfCells());
 visual->Popup();
 visual->SetPaletteRGB(0, 255, 255, 255); //White background
 visual->SetPaletteRGB(1, 0, 0, 0);       //Black foreground
 visual->SetPaletteRGB(2, 255, 0, 0);     //Red
@end smallexample

You have already used one of the abstract functions of @code{CAModel},
@code{AllocateCells()}, so now it is time to implement it. This function
shall allocate the number of cells specified by the parameter. First
must the array of @code{CACell} pointer allocates, then you must use a
@code{for} loop to allocate each cell. The function is now:
@smallexample
void GameOfLife::AllocateCells(int new_cells)
@{
 int i;
 for (i=0; i<cells; i++)
    @{
    delete cell[i];
    @}
 
 delete [] cell;

 cells = new_cells;
 cell = new (CACell*)[cells];

 for (i = 0;i < cells; i++)
    @{
    cell[i]=new LifeCell;
    @}
@}
@end smallexample

The next function to implement is @code{Draw}, this function is called
every time a cell is drawn. We want to draw the cell in the background
color if it is dead, and in color 2 (we defined it to be read) if it is
alive. The function that does this is like this:

@smallexample
void GameOfLife::Draw(int cell_index)
@{
 LifeCell *current = (LifeCell*) cell[cell_index];
 
 if(current->Alive())
    @{
    symbol->Draw(cell_index, 2);
    @}
 else
    @{
    symbol->Draw(cell_index, 0);
    @}
@}
@end smallexample

The last function you must inherit is @code{Update()}, this is the
function that defines the rules to update the states of the
cells. Because most of this function is different from what you need
will it not be described here. For more information @xref{The CAGrid object}
and @file{GoLModel.C}.

@node Making GoLApp, Making main(), Making The GameOfLife object, Game of life
@section Making GoLApp
We did not create separate header file and source file for this object,
because this is the @emph{application object}. The constructor and
destructor of this class is empty. You only need to implement to
functions, @code{Initialize} and @code{NewModel}.

Start with @code{Initialize}, since this function is not abstract and you
do not want to override the superclasses function you must start with
calling the superclasses function. Then you may add the menu
item. @xref{Making Menus}. 
@smallexample
void GameOfLife::Draw(int cell_index)
@{
 LifeCell *current = (LifeCell*) cell[cell_index];
 
 if(current->Alive())
    @{
    symbol->Draw(cell_index, 2);
    @}
 else
    @{
    symbol->Draw(cell_index, 0);
    @}
@}

@end smallexample

The first argument in @code{AddItem} is the name of the item, the next is
the function and the last must always be
@code{this}. 

@code{Initialize()} is a @emph{callback function}, and must
therefore be declared @code{static}. @xref{Events and Callbacks}. It
only needs to instanciate a @code{GameOfLife} object, and add it to the
list of models. The whole class will now look like this:
@smallexample
#include <CAApp.h>
#include <GoLModel.h>
#include <GoLCell.h>

class GoLApp : public CAApp
@{
private:

protected:
   
public:
   GoLApp();
   ~GoLApp();
   virtual void Initialize(int argc, char **argv);
   static void NewModel(Widget w, XtPointer data, XtPointer garbage);
@};

GoLApp::GoLApp()
	:CAApp()
@{
@}


GoLApp::~GoLApp()
@{
@}

void GoLApp::Initialize(int argc, char **argv)
@{
 CAApp::Initialize(argc, argv);
 model_menu.AddItem("Game of life", NewModel, (XtPointer) this);
@}

void GoLApp::NewModel(Widget w, XtPointer data, XtPointer garbage)
@{
 GoLApp *app = (GoLApp*)data;
 CAModel *model = new GameOfLife(app->toplevel);
 app->model_list->Add(model);
@}

@end smallexample

As you see all referances to the class member in @code{NewModel()} is
done via @code{app}, this is because the function is @code{static} and
not connected to a object.

@node Making main(),  , Making GoLApp, Game of life
@section Making main()

The @code{main()} function in any CASE application will be like this:
@example
int main(int argc, char **argv)
@{
 GoLApp app;
 app.Initialize(argc, argv);
 app.Popup();
 app.MainLoop();
@}
@end example
The only difference in @code{main()} is what subclass of @code{CAApp} is used.

@c **********************************************************************
@c CHAPTER - Requesters
@c **********************************************************************

@node Requesters, The CAApp object, Game of life, Top
@chapter Requesters
There are two major types of requesters provided by CASE. 

@enumerate
@item Requesters Implemented as a separate C++ class
@item Custom requesters based on the @code{Req} class
@end enumerate

In the first category you have such requesters as the file requester and
the color requester. In the second category you will find the
environment requester which is dynamically created by the CAEnviron
object.

@menu
* The cell requester::          
* The environ requester::       
* The color requester::         
* File Requester::              
@end menu

@node The cell requester, The environ requester, Requesters, Requesters
@section The cell requester
The cell requester is made to change the properties of one cell. It is
usually activated by clicking in the cell you want to change. This is
configurable when @code{CAModel} is inherited. 

The implementation of this requester may seem complex, but if you take a
closer look you will see that it is very easy to use. We needed a way to
handle rhe requester without each property having its own pointer. This
is solved by letting @code{CACell} give each @code{CAProperty} its own
name, under which it may add as many widgets as it needs. These names
are hardcoded in @code{CACell}, so that they do not need a pointer
each. The subclass of @code{CAProperty} is likely to use this name in
one of the widgets, eg. label.

With this structure the only class that directly communicates with the
widgets are @code{CAProperty}. Each function used to handle this
requester is described in the chapter for the appropriate class.

@node The environ requester, The color requester, The cell requester, Requesters
@section The environ requester

@iftex
@sp 10
@special{psfile=EnvironReq1.eps vscale=50 hscale=50 hoffset=180 voffset=9}
@end iftex
@center{@i{The Environment requester of the @code{CARectangularGrid} Environment}}

The Environ requester is used to set some parameters in @code{CAEnviron} (or
it's subclass). It will popup if the menu option: control-settings is
chosen. By default a toggle button is used to choose if the boudries are
periodic. If you are using a subclass of @code{CAGrid}, the number of rows and
columns are also prompted. To pop the requester down simply press the "Ok"
or "Cancel" button. If you press "Cancel" your changes will be ignored.

If the rows and columns are changed so the total number of cells are
changed, all cells must be reallocated. Therfore
@code{CAModel::ReadEnvironRequester()} is called. It is this function in
that calls the ReadRequester in CEnviron. 

The @code{Req} object is designed to let several groups of widgets be in the
same requester. This makes it easy for one subclass of @code{CAEnviron} to add
widgets without worrying about how this will affect the placement of
other widgets. 
@page
@c -------------------------------------------------------------------------------
@c SECTION Color Requester
@c -------------------------------------------------------------------------------
@node The color requester, File Requester, The environ requester, Requesters
@section The color requester

@menu
* Color Requester Introduction ::  
* Col Req Programming Interface::  
* Col Req Public member Functions::  
@end menu

@iftex
@sp 10
@special{psfile=ColorReq1.eps vscale=50 hscale=50 hoffset=180 voffset=20}
@end iftex
@center{@i{A color requester with 3 colors}}

@node Color Requester Introduction , Col Req Programming Interface, The color requester, The color requester
@subsection Introduction 

This is a color/palette requester to set the colors used by an @code{X2DView}
widget. It is implemented as a C++ class object. It was originally a
general requester for @code{X2DView} but has been modified to work better with
the CASE project. The window contains a group of buttons,
three scrollbars, an "Ok" button and a "blend" button. A color requester
with 3 colors is shown in the figure below:

Each button in the group represents a color cell in the palette used in
the widget. They are positioned after their index, placing color 0 to the
top left. Color 0 is used as the background color, while color 1 is the
default foreground color. This is specified in the @code{X2DView}
widget. @xref{The color palette} for more information. You select a
color by clicking on it, the frame will then be red.

The colors are based on RGB values, and each scrollbar has  one of these
colors. By draging on one of the scrollbars you change the color in the
selected color cell. This change happends directly in the color palette,
so you may not cancel the change. 

The blend function is activated by first selecting the start color, so
pressing the blend button, so selecting the end color. Blend change al
colors between the start and the end color, so they will be spread
smoothly. 

@node Col Req Programming Interface, Col Req Public member Functions, Color Requester Introduction , The color requester
@subsection Programming Interface

The modified version of ColorReq is tied up to an @code{CAVisual}
object. Therefore it only needs a pointer to a popped up @code{CAVisual}
object. The color requester must be instantiated as a pointer to a class
object, because it has no public default constructor. It has only one
public member function: @code{Show}. There is no reason to read the values of
these requester, because it changes the colors in @code{CAVisual} the the
moment one scrollbar is moved.

@node Col Req Public member Functions,  , Col Req Programming Interface, The color requester
@subsection Public member Functions

@c @node ColorRequester::ColorRequester (),  , Color requester, Color requester
@c @subsubsection ColorRequester::ColorRequester ()}
@deffn constructor ColorReq::ColorReq (CAVisual *new_visual)

@exdent @b{Arguments}
@var{new_visual}@*
Specifies the visual that is using the requester.

@exdent @b{Return value}
None.

@exdent@b{Description}
The default constructor must not be used, you @emph{must} use a pointer
to a visual as parameter.


@exdent @b{See also}
Nothing appropriate
@end deffn
@page

@c @node ColorRequester::Show (),  , Color requester, Color requester
@c @subsubsection ColorRequester::Show ()}
@deftypefun void ColorRequester::Show (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None.

@exdent@b{Description} 
This is the only public member function in @code{ColorRequester}. It pops up
the requester if it is not popped up yet.

@exdent @b{See also}

@end deftypefun
@page
@c -------------------------------------------------------------------------------
@c -------------------------------------------------------------------------------
@c SECTION File Requester
@c -------------------------------------------------------------------------------
@node File Requester,  , The color requester, Requesters
@section The File Requester object
@menu
* File Requester Introduction::  
* Fil Req Programming Interface::  
* Fil Req Public member functions::  
@end menu

@node File Requester Introduction, Fil Req Programming Interface, File Requester, File Requester
@subsection Introduction


@iftex
@sp 20
@special{psfile=filereq.ps vscale=60 hscale=60 hoffset=50 voffset=-100}
@end iftex
@center{@i{A typical file requester}}

This is an X11 file requester implemented as a C++ class object. It
looks a bit like the Amiga ASL file requester, and its programming
interface is also quuite similar because of  the data types 
and tag/value pairs interface.

Using the file requester should be quite straightforward. The requester
constists of:
 
@itemize @bullet
@item file list for the current directory with filename, file
      size and permissions. 
@item OK and Cancel buttons.
@item Directroy Buttons; Home, Root and Parent. 
@item A filename text input field.
@item A Pathname static text field.
@end itemize


To select a file, click on it in the file list and click OK. To change
directory selct a directory in the list and click OK. You can also
change to the predefined locations 'HOME' as given in your @code{$HOME}
environment variable, and 'Root' which is the top of the file tree. The
'Parent' button moves you one directory up, same as selecting @code{..}
and clicking 'OK'.
 
@c----------------------------------------------------------------------

@node Fil Req Programming Interface, Fil Req Public member functions, File Requester Introduction, File Requester
@subsection Programming Interface

The File requester can be instantiated either as a pointer to a class
object or directly. The various parameters of the file requesters are
set using a variable length array of @emph{tags} and @emph{tag values}
as parameters either to the constructor or to the @code{Initialize}
method. Each tag has a corresponding tag value, which can be of
varying type. The order of the tag/value pairs is not significant. 

The tag list @emph{must} be terminated by the special tag
@code{TAG_DONE}. If this is not done, a segmentation fault will occur. 

Each tag has a default value, and no tags have to be given in the
parameter list, except @code{TAG_DONE}.

The tags and their types and default values are listed in table
below.

@menu
* File requester tags::         
@end menu

@node File requester tags,  , Fil Req Programming Interface, Fil Req Programming Interface
@subsubsection File requester tags

@tex
\hskip 12pt
\vbox{\offinterlineskip
\halign{\strut \vrule \quad {\tt #} \quad 
        & \vrule \hfil \quad {\tt #} \hfil 
        & \quad \vrule \hfil \quad #\quad\hfil\vrule\cr
\noalign{\hrule}
{\rm \bf TagName} & {\rm \bf Type} & {\bf Default Value}\cr
\noalign{\hrule}
 FRQ\_Title         & char *        & ``FileRequester''\cr 
 FRQ\_Width         & int           & 310\cr
 FRQ\_Height        & int           & 310\cr
 FRQ\_LeftEdge      & int           & 10\cr
 FRQ\_TopEdge       & int           & 10\cr
 FRQ\_OKText        & char *        & ``OK''\cr
 FRQ\_CancelText    & char *        & ``Cancel''\cr
 FRQ\_File          & char *        & NULL\cr
 FRQ\_Dir           & char *        & NULL\cr
 FRQ\_Type          & int/spec      & FRQ\_Load\cr
 FRQ\_FileDoneFunc  & void (fptr *)(FileRequester *) & NULL\cr
\noalign{\hrule}
}}

@end tex

@noindent
@b{FRQ_Title} This tag describes the title text of the file
requester an must be of type @code{char *}.

@noindent
@b{FRQ_Width} Describes the width of the file requester in
pixels. Must be integer.

@noindent
@b{FRQ_Height} Describes the height of the file requester in
pixels. Must be integer.

@noindent
@b{FRQ_LeftEdge} Describes the left edge of the file requester,
relative to the left edge of the screen. The unit is pixels, and the
type is integer.

@noindent
@b{FRQ_TopEdge} Describes the top of the file requester,
relative to the top of the screen. The unit is pixels, and the
type is integer.

@noindent
@b{FRQ_OKText} A character string describing the text to be
displayed in the OK button in the file requester. 

@noindent
@b{FRQ_CancelText} A character string describing the text to be
displayed in the Cancel button in the file requester. 

@noindent
@b{FRQ_File} A character string providing an initial file name
for the file requester.

@noindent
@b{FRQ_Dir} A character string providing an initial directory name
for the file requester.

@noindent
@b{FRQ_Type} A flag describing the type of the file
requester. The file requester can either be a @emph{load} requester,
in which it is not possible to write in the file name field, or it can
be a @emph{save} requester where you can write the name of a
non-existing file in the file name field. This tag can have one of the
two values @code{FRQ_Load} or @code{FRQ_Save}.

@noindent
@b{FRQ_FileDoneFunc} This tag describes a function which will be
called when the user pushes the OK button with a regular file
selected. The function must be defined as @code{static void} and
with exactly one argument, which is a pointer to a
@code{FileRequester} class object. 

@noindent
@b{FRQ_TAGS} Terminates the taglist.
@page 
@menu
* Public member functions::     
@end menu

@node Fil Req Public member functions,  , Fil Req Programming Interface, File Requester
@subsection Public member functions

@c-------------------------------------------------------------------------------
@c @subsubsection Constructors}
@deffn void FileRequester::FileRequester (void)
@deffnx void FileRequester::FileRequester (Widget @var{parent},...);

@exdent @b{Arguments}
@parskip 0pt
@table @var
@item  parent  
The parent widget of the file requesters toplevel widget
@item ... 
A variable length list of tag/value pairs. See @emph{File requester tags}.
@end table 
@parskip 12pt

@exdent @b{Return value}@*
None.

@exdent@b{Description}@*
The first one does nothing really, it just initializes some of the data
members to NULL. The second one sets up the file requester according
to the values of the @emph{file requester tags}.

@exdent @b{See also}@*
Nothing appropriate

@end deffn

@noindent
@b{Example}
@smallexample
 FileRequester *fr;

 @dots

 fr = new FileRequester(main_window,  
                        FRQ_Title, "WOW!!",
                        FRQ_TopEdge, 100,
                        FRQ_LeftEdge, 200,
                        FRQ_CancelText, "Forget it!",
                        FRQ_Type, FRQ_Load,
                        FRQ_FileDoneFunc, Load,
                        TAG_DONE );

@end smallexample
@page

@c-------------------------------------------------------------------------------
@c @subsubsection Initialize}
@deftypefun void FileRequester::Initialize (Widget @var{parent}, @var{...})

@exdent @b{Arguments}
@parskip 0pt
@table @var
@item  parent  
The parent widget of the file requesters toplevel widget
@item ... 
A variable length list of tag/value pairs. See @emph{File requester tags}.
@end table 
@parskip 12pt

@exdent @b{Return value}@*
None.

@exdent @b{Description}@*
This function does exactly the same thing as the second constructor
described previously. It is intended for use where the @code{FileRequester}
object is not a pointer, and is instantiated with the defalt
constructor.

@exdent @b{See also}@*
Nothing appropriate
@end deftypefun

@noindent 
@b{Example}
@smallexample
 FileRequester fr;
 
 @dots

 fr.Initialize(toplevel, 
               FRQ_Title, ``Open File'',
               FRQ_Width, 200,
               FRQ_Height, 300,
               TAG_DONE);
@end smallexample
@page

@c-------------------------------------------------------------------------------
@c @subsubsection Popup}
@deftypefun int FileRequester::Popup (void)

@exdent @b{Arguments}@*
None

@exdent @b{Return value}@*
Zero for failure and non-zero for success

@exdent @b{Description}@*
This function opens the file requester on the same display as the
widget given as @code{parent} argument to the constructor or
@code{Initialize}. The requester is not popped down again until the
user presses the @emph{OK} or @emph{Cancel}-button. 

@exdent @b{See also}@*
Nothing appropriate
@end deftypefun

@noindent
@b{Example}
@smallexample
 file_button = XtVaCreateManagedWidget("filebutton",
                                       commandWidgetClass,
                                       main_window,
                                       XtNlabel, "Load@dots ",
                                       NULL);
 XtAddCallback(file_button,XtNcallback, OpenFR, fr);

 @dots

 static void OpenFR(Widget w, XtPointer data, XtPointer garbage)
 {
 FileRequester *fr = (FileRequester *)data;
 fr->Popup();
 }
@end smallexample
@page

@c-------------------------------------------------------------------------------
@c @subsubsection GetFileName, GetDirName}
@findex FileRequester::SetFileName
@deftypefun char *FileRequester::GetFileName (void)
@deftypefunx char *FileRequester::GetDirName (void)

@exdent @b{Arguments}@*
None

@exdent @b{Return value}@*
pointer to string containing the currently selected file name or
directory name.

@exdent @b{Description}@*
These functions returns the file name and directory name which is
currently selected in the file requester. These are typically used in
the function given by @code{FRQ@_FileDoneFunc} to retrieve the path
to the wanted file.

@exdent @b{See also}@*
Nothing appropriate
@end deftypefun

@noindent
@b{Example}
@smallexample
 fr = new FileRequester(main_window,  
                        FRQ_Type, FRQ_Load,
                        FRQ_FileDoneFunc, Load,
                        TAG_DONE );

 @dots

 static void Load(FileRequester *fr)
 {
 cout << "Loading file " << fr->GetFileName() << endl;
 cout << "Directory: " << fr->GetDirName() << endl;
 }
@end smallexample
@page



@c **********************************************************************
@c CHAPTER - The CAApp object
@c **********************************************************************

@node The CAApp object, The CAModel object, Requesters, Top
@chapter The CAApp object

This is the main class in the hierarchy. It is used to control the
application in various vays, e.g starting and stopping simulations, and
opening new frames. It also controls the timeouts for updating of
@code{CAModel} objects. The CAApp object in itself is not very usable,
and each simulation program must inherit it an make a new application class.

@c -------------------------------------------------------------------------------
@c SECTION Introduction
@c -------------------------------------------------------------------------------
@menu
* Introduction::                
* Functions::                   
@end menu

@node Introduction, Functions, The CAApp object, The CAApp object
@section Introduction
@code{CAApp} is the only object that @code{main} interacts with. Actualy the
only @code{main} should do is to choose which subclass of @code{CAApp} the
application should use.

@code{CAApp} contains a poiter to a @code{CAModelList} object. This is a
linked list of @code{CAModel} objects which are currently in use. Each time you
instantiate a @code{CAModel} you chould add it to this list. @code{CAApp} will
call the @code{Update} funtion of all models in the model list at regular
intervals. @var{interval} specifies the interval between two updates.

@code{CAApp} creates and pops up the main window (also called control
window). This window contains a menu, three buttons and a scrollbar. The
buttons are used to stop and start simulations and are associated with
callback functions in the object. The scrollbar changes the interval
between drawing updates from 10ms to 1s, effectively changing the speed
of the running simulation. A subclass of @code{CAApp} must add menu items
for the models that the application should be able to use. For more on
how to create menus and adding items to them, see @ref{Making Menus}

The default application window is shown in the figure below.

@iftex
@sp 10
@special{psfile=CAApp1.ps vscale=60 hscale=60 hoffset=150 voffset=10}
@end iftex

As by all abstract classes, you must inherit @code{CAApp} before you
instantiate it. The only parameters given is @code{argc} and @code{argv}
to get the command line parameters. @code{CAApp} only contains three
public member functions, and you must call all of them in predefined
order:

@itemize
@item Initialize (argc argv); 
@item Popup()
@item MainLoop();
@end itemize
@page

@node Functions,  , Introduction, The CAApp object
@section Functions
All public functions of @code{CAApp} will be described here. The discription
will include how the funtions are ment to be inherited.

@deffn constructor CAApp::CAApp ()
@exdent @b{Arguments}
None

@exdent @b{Return value}
None.

@exdent@b{Description}
This is the default constructor for the @code{CAApp} object. Initializes all
data members to approperate values.

@exdent @b{See also}
Nothing appropriate
@end deffn
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAApp::Initialize (int argc, char **argv)
@exdent @b{Arguments}
@var{argc}@*
Specifies the number of command line parameters.

@var{argv}@*
Specifies the command line parameters.

@exdent @b{Return value}
None.

@exdent@b{Description} 
This method sets up the control window, with
menu, buttons and scollbar. To do this it For that it needs the command line
parameters. It does not pop up the window.

@exdent@b{Inheritance} 
You must inherit this function if you want to be
able to start any simulation. You should add at least one menu-item
under the model_menu. You may also add buttons or other widgets to the
control window, but then you are on your own, @code{CAApp} does not provide any
help for extra widgets. 

@exdent @b{See also}
@ref{Making Menus}
@end deftypefun
@noindent
@b{Example}
@smallexample
void GoLApp::Initialize (int argc, char **argv)
@{
 CAApp::Initialize(argc, argv);
 model_menu.AddItem("Game of life", NewModel, (XtPointer) this);
@}
@end smallexample

This is the @code{Initialize} function of the @code{GoLApp} class. It
adds a menu item for starting a `game of life' model.
@page
@c -------------------------------------------------------------------------------
@deftypefun void CAApp::Popup ()

@exdent @b{Arguments}
none
@exdent @b{Return value}
None.

@exdent@b{Description}
This method pop's up the control window. After the window is popped up
it adds bitmaps to the buttons. It is important that the window is
popped up before bitmaps are addet to it, otherwise you will get an X-error.

@exdent@b{Inheritance} 
You must inherit this function if you want to add a bitmap to a widget.

@exdent @b{See also}
@ref{The AddBitmapToWidget function}
@end deftypefun
@page
@c -------------------------------------------------------------------------------

@deftypefun void CAApp::MainLoop (void)
@exdent @b{Arguments}
none

@exdent @b{Return value}
None.

@exdent@b{Description} 
This method starts the main loop, e.g gives Xt
the control of program flow. This means that any statements after this
function call will not be executed.


@exdent @b{See also}
Nothing appropriate
@end deftypefun
@c @page
@c -------------------------------------------------------------------------------

@c **********************************************************************
@c CHAPTER - The CAModel object
@c **********************************************************************

@node The CAModel object, The CAEnviron object, The CAApp object, Top
@chapter The CAModel object

@menu
* CAModel Introduction::        
* CAModel Functions::           
@end menu

@node CAModel Introduction, CAModel Functions, The CAModel object, The CAModel object
@section Introduction

This object class is the ``heart'' of the simulation system. It is
responsible for updating the simulation of the Cellular Automaton
according to a given set of rules. These rules must be hardcoded in the
object, but it is easy for the user to make new simulations by defining
a new model class as a child of @code{CAModel}.

@code{CAModel} has "responsibility" for @code{CAEnviron},
@code{CAVisual} and @code{CACell}. By this we mean that @code{CAModel}
must instantiate and delete these objects. Most function calls to these
object will also be sent from @code{CAModel} to the respective
objects. Because it is the inherited version of @code{CAModel} that
chooses which subclasses to be used, the superclass does not instantiate
any objects (except requesters).

When a new model class is defined as a child of @code{CAModel} these methods
must be defined:

@itemize @bullet
@item Update()
@item Draw(int cell_index)
@item AllocateCells(int new_cells)
@end itemize


@node CAModel Functions,  , CAModel Introduction, The CAModel object
@section Functions

Here you will find all functions you need to either re-define, or
call. The functions will be divided in public and protected member
functions. The private member functions will not be described in this
document.

@menu
* CAModel Public member functions::  
* Protected member functions::  
@end menu

@node CAModel Public member functions, Protected member functions, CAModel Functions, CAModel Functions
@subsection Public member functions

@page
@deffn constructor CAModel::CAModel (void)
@deffnx constructor CAModel::CAModel (Widget new_parent)
@exdent @b{Arguments}
@var{argc}@*
The parent widget of the windows @code{CAModel} will popup. This may be any
popped up widget in the application. Usually the toplevel widget in the
control window is used.

@exdent @b{Return value}
None.

@exdent@b{Description}
The default constructor must not be used, you @emph{must} use a widget
as parameter.


@exdent @b{See also}
Nothing appropriate
@end deffn
@page

@c -------------------------------------------------------------------------------
@deftypefun void CAModel::Update (void)
@exdent @b{Arguments}
none

@exdent @b{Return value}
None.

@exdent@b{Description} 
In the introduction we stated that @code{CAModel}
is the heart of the simulation system, in the same way @code{Update} is
the heart of @code{CAModel}. This is where the rules for updating are
specified. This usually means traversing trough all cells one or more
times, to determine what their new state schould be, and then drawing
cells according to their new state. It is also here you would write
relevant information to the text area

@exdent@b{Inheritance}
This function is abstract, so it must be
inherited.  Usually it is a good idea to redraw only the cells that
changed one or more properties. Models which use double buffering
however, should call Redraw to update the whole picture.

@exdent @b{See also}
@code{CAApp::CAApp()}, @code{Redraw()}, @code{Double-Buffering}

@end deftypefun

@page
@c -------------------------------------------------------------------------------

@c -------------------------------------------------------------------------------
@deftypefun void CAModel::Redraw (void)
@exdent @b{Arguments}
none

@exdent @b{Return value}
None.

@exdent@b{Description} 
This function redraws the whole picture. This is done by first clearing the
graphics area and then traversing all cells and calling @code{Draw(cell_index)}.
If the draw_grid option is set it will also draw the grid.

@exdent@b{Inheritance} 
Most models do not need to intherit this function, but if you wish to use
double buffering you must override it.

@exdent @b{See also}
@code{CAApp::CAApp()}, @code{Draw()}

@end deftypefun

@page

@c -------------------------------------------------------------------------------
@deftypefun void CAModel::Click (int @var{x}, int @var{y})
@exdent @b{Arguments}
@var{x}@*
Specifies the x-position that the mouse button was pressed.

@var{y}@*
Specifies the y-position that the mouse button was pressed.


@exdent @b{Return value}
None.

@exdent@b{Description} 
@code{CAVisual} will call this function when it recives a mouse-button click inside 
the graphics area. It could be used for example to manually change the
state of a cell through a requester. By default the cell requester will be popped up. 

@exdent@b{Inheritance}
If you want something else to happen you may override this function. 
By calling @code{environ->QueryCell(x, y)}  you will get the cell index
to the appropriate cell.

@exdent @b{See also}
@code{CAApp()}, @code{environ::QueryCell()}
@end deftypefun

@noindent
@b{Example}
@smallexample
void GameOfLife::Click(double x, double y)
@{
 int cell_index;
 cell_index = environ->QueryCell(x, y);
 LifeCell *current = (LifeCell*) cell[cell_index];
 if (current->Alive())
    @{
    current->SetAlive(False);
    @}
 else
    @{
    current->SetAlive(True);
    @}
 Draw(cell_index);
@}
@end smallexample
This example illustrates how the @code{Click} function is defined in the "game of
life" model. This causes the cell to toggle state between dead and alive.
@page
@c -------------------------------------------------------------------------------
@deftypefun void CAModel::CoordinatesChanged (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None.

@exdent@b{Description} 
@code{CAVisual} calls this function when the coordinates is changed,
i.e when you zoom or resize the window. This will cause the window
to be cleared, and by default @code{Redraw} will be called.

@exdent@b{Inheritance}
As it is it simply calls @code{Redraw}, that is usually what you want to happen.

@exdent @b{See also}
@code{Redraw()}
@end deftypefun
@page
@c -------------------------------------------------------------------------------
@deftypefun Widget CAModel::GetToplevelWidget (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
The Widget specified by the constructor.

@exdent@b{Description} 
Many objects and functions need to be associated with a widget. This
function returns the toplevel widget which was proveded in the
@code{CAModel} constructor. This function was made mainly to reduce the parameters to
@code{CAVisual}, as @code{CAVisual} will run this function to set its
toplevel widget

@exdent @b{See also}
Nothing appropriate
@end deftypefun
@page
@c -------------------------------------------------------------------------------
@node Protected member functions,  , CAModel Public member functions, CAModel Functions
@subsection Protected member functions
@deftypefun void CAModel::AllocateCells (int @var{new_cells})
@exdent @b{Arguments}
@var{new_cell}@*
Specifies the number of cells to allocate

@exdent @b{Return value}
None

@exdent@b{Description} 
This function deletes all cells and allocates @var{new_cells} cells. 

@exdent@b{Inheritance} The procedure is abstract, so inheritance is
reqired. But it is straightforward to implement, you only have to chance
one word from the example: @emph{LifeCell}.

@exdent @b{See also}
Nothing appropriate
@end deftypefun
@noindent
@b{Example}
@smallexample
void GameOfLife::AllocateCells(int new_cells)
@{
 int i;
 for (i=0; i<cells; i++)
    @{
    delete cell[i];
    @}
 
 delete [] cell;

 cells = new_cells;
 cell = new (CACell*)[cells];

 for (i = 0;i < cells; i++)
    @{
    cell[i]=new LifeCell;
    @}
@}
@end smallexample
This example should demonstrate how the function should be implemented.
@page
@c -------------------------------------------------------------------------------
@deftypefun void CAModel::Draw (int cell_index)
@exdent @b{Arguments}
@var{cell_index}@*
Specifies wich cell to draw.

@exdent @b{Return value}
None

@exdent@b{Description} 
This function draws the cell with cell index @var{cell_index}.

@exdent@b{Inheritance}
The procedure is abstract, so inheritance is reqired. Usually this means
just to call the @code{Draw} function of the @code{CASymbol} object you
are using with parameters according to the properties of the cell.

@exdent @b{See also}
 @ref{The CASymbol object}

@end deftypefun
@noindent
@b{Example}
@smallexample
void GameOfLife::Draw(int cell_index)
@{
 LifeCell *current = (LifeCell*) cell[cell_index];
 
 if(current->Alive())
    @{
    symbol->Draw(cell_index, 2);
    @}
 else
    @{
    symbol->Draw(cell_index, 0);
    @}
@}
@end smallexample
This example draws the cell with color 2 if it is alive, and with color
0 if it is dead. To do this symbol must be declared in a subclass of
@code{CAModel}. In this example it is declared as
@code{CAColoredEllipseSymbol}.
@page
@c -------------------------------------------------------------------------------
@deftypefun void CAModel::PopupEnvironRequester (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None.

@exdent@b{Description} This function checks whether or not a environ
reqester is defined, if it is not defined, it will first call the
@code{SetupRequester} function in @code{CAEnviron}. Then it opens the
Environment requester window if any, on the screen

@exdent @b{See also}
@code{CAEnviron::SetupRequester}, @ref{The environ requester}

@end deftypefun
@page
@c -------------------------------------------------------------------------------
@deftypefun void CAmodel::PopupCellRequester (int @var{cell_index})
@exdent @b{Arguments}
@var{cell_index}@*
Specifies the cell.

@exdent @b{Return value}
None.

@exdent@b{Description} 
This function checks wether a cell reqester is defined, if not it calls 
@code{SetupRequester}  of the cell indexed by cell_index. If the
@code{CACell} object is made according to our guidelines, this the only
function call needed to use the cell requester.

@exdent @b{See also}
@ref{The CACell object}, @ref{The cell requester}, @ref{The Req object}

@end deftypefun
@page
@c -------------------------------------------------------------------------------

@deftypefun void  CAModel::ReadEnvironRequester (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None.

@exdent@b{Description} 
This functon reads the environ requester, default it calls
@code{environ::Readrequester}.

@exdent@b{Inheritance}
If the changes in @code{CAEnviron} demands an action in @code{CAModel},
you must inherit this function and do it here. One example is if the
total number of cells is changed.

@exdent @b{See also}
@ref{The CACell object}, @ref{The cell requester}, @ref{The Req object}
@end deftypefun
@noindent
@b{Example}
@smallexample
void GameOfLife::ReadEnvironRequester()
@{
 CAModel::ReadEnvironRequester();
 CAGrid *grid = (CAGrid*) environ;
 if (cells != grid->GetNumberOfCells())
    @{
    AllocateCells(grid->GetNumberOfCells());
    @}
 Redraw();
@}
@end smallexample
This example demonstrates how to reallocate the cells after the environ
requester is read.
@page
@c -------------------------------------------------------------------------------

@c **********************************************************************
@c CHAPTER - The CAEnviron object
@c **********************************************************************

@node The CAEnviron object, The CACell object, The CAModel object, Top
@chapter The CAEnviron object

@menu
* CAEnviron Introduction::      
* CAEnviron Functions::         
@end menu

@node CAEnviron Introduction, CAEnviron Functions, The CAEnviron object, The CAEnviron object
@section Introduction 
This object defines the geometry in which the cells of a simulation are
ordered. This geometry may be square, hexagonal, triangular, etc. And it
is even possible to make a ``floating'' pattern, i.e. no fixed positions
for the cells. The CASE library currently only provides the fixed grid
class and its derivatives. It should be straightforward to extend this
with support for ''floating pattern''.

In most cellular automata the cells are placed in a predefined
pattern, and we concentrated on those. We wanted to make sure that if a
model is implemented correctly it should be possible to change the pattern
during runtime. To do this we made a subclass of @code{CAEnviron},
called @code{CAGrid}, you should only use functions declared here. Also
if you are making new class for a pattern not yet implemented, make the
class a subclass of @code{CAGrid}. We have tried to push the functions
as high up in the inheritance hierachy as possible. This makes it more
flexible when the classes are used.

@code{CAEnviron} contains the  size of the  coordinate system in logical
coordinatres, i.e this  is not the  pixel size of the  window. @xref{The
coordinate system}. You   should update this with  the  @code{SyncViewport}
function  to ensure that @code{CAEnviron}   and @code{CAVisual} uses the
same coordinates.  

In some models it may be useful if the cells on opposite ends of the
grid are treated as neghbours. I.e. The upper right cell is neighbour
the lower right cell. Thus @code{CAEnviron} contains a boolean variable
specifying wether the boundaries are periodic (wrap-around) or not.

@c -------------------------------------------------------------------------------
@c SECTION Introduction
@c -------------------------------------------------------------------------------
@menu
* Functions::                   
@end menu

@node CAEnviron Functions,  , CAEnviron Introduction, The CAEnviron object
@section Functions
Most of the functions are supposed to be inherited, so we will describe
both how to use them and how they are ment to be inherited.

@deffn constructor CAEnviron::CAEnviron (double new_x_min, double new_y_min, double new_x_max, double new_y_max)
@exdent @b{Arguments}
@var{new_x_min}@* @var{new_y_min}@* @var{new_x_max}@* @var{new_y_max}@*
Specifies the dimensions of the coordinate system.

@exdent @b{Return value}
None.

@exdent@b{Description}
All the parameters has default values. Remember that the values must be
the same in @code{CAVisual}, therefore it is best to use
@code{SyncViewport()} after these values have been set.

@exdent @b{See also}
@code{SyncViewport()}, @code{The CAVisual object}
@end deffn
@page
@c -------------------------------------------------------------------------------
@deffn constructor CAEnviron::CAEnviron (CAVisual *@var{visual})
@exdent @b{Arguments}
@var{visual}@*
A pointer to a @code{CAVisual} object.

@exdent @b{Return value}
None.

@exdent@b{Description}
This constructor retrieves the coordinate dimensions from.

@exdent @b{See also}
@code{SyncViewport()}, @code{The CAVisual object}
@end deffn
@page
@c -------------------------------------------------------------------------------
@deftypefun void CAEnviron::SyncViewport (CAVisual *@var{visual})

@exdent @b{Arguments}
@var{visual}@*
Specifies the @code{CAVisual} object.

@exdent @b{Return value}
None.

@exdent@b{Description} 
This function is made to ensure that the @code{CAVisual} object and the
@code{CAEnviron} object are using the same dimensions in the coordinate system.

@exdent@b{Inheritance}
If you have data members that are dependent on the boundaries they should
be re-calculated here.

@exdent @b{See also}

@code{CAApp}, CAEnviron, @ref{The environ requester}
@code{SyncViewport()}, @code{The CAVisual object}
@end deftypefun

@page
@c -------------------------------------------------------------------------------
@deftypefun void CAEnviron::QueryPosition (int @var{cell_index}, double &@var{x}, double &@var{y})

@exdent @b{Arguments}
@var{cell_index}@*
Specifies the cell.

@exdent @b{Return value}
@var{x}@*
Returns the position of the center in x-direction

@var{y}@*
Returns the position of the center in y-direction

@exdent@b{Description} 
The function returns the position of the cell with index
@var{cell_index}. It is placed in @code{CAEnviron} instead of
@code{CAGrid} so that all symbols also can be used in an environment
where there is no fixed grid geometry.

@exdent@b{Inheritance}
This is an abstract function because no geometry is defined in
@code{CAEnviron}. It should return the center@footnote{It might not
be the real center. The main point  is that any vector of length 1 should
be inside the boundaries of the cell if it is multiplied with the
scaling factors returned by @code{QueryScaleFactors}.} of the cell. Most
symbols use this function to place the symbol.

@exdent @b{See also}
@code{QueryScaleFactors}
@end deftypefun
@page
@c -------------------------------------------------------------------------------
@deftypefun int CAEnviron::QueryCell (double @var{x}, double @var{y})

@exdent @b{Arguments}
@var{x}@*
Specifies the x coordinate

@var{y}@*
Specifies the y coordinate

@exdent @b{Return value}
The index to the cell located at (x,y).

@exdent@b{Description} 
This function returns the index to the cell located at (x,y). It can be
used for instance
to determine which cell the mouse button was clicked on. 


@exdent@b{Inheritance}
This is an abstract function which you must inherit. Remember that the
coordinates are based on logical coordinates, not window coordinates.  

@exdent @b{See also}
@ref{The coordinate system}
@end deftypefun
@noindent
@b{Example}
@smallexample
int CARectangularGrid::QueryCell(double x, double y)
@{
 double dx, dy;
 int col, row, cell_index;
 
 dx = (x_max - x_min)/ (double) cols;
 dy = (y_max - y_min)/ (double) rows;

 col = (int) ((x-x_min)/dx);
 row = (int) ((y-y_min)/dy);
 cell_index = row*cols + col;
 return cell_index;
@}

@end smallexample
This example is @code{CARectangularGrid} implementation of
@code{QueryCell}. It will not be quite this simple in other subclasses,
but it should be possible to implement it.

@noindent
@b{Example}
@smallexample
void CAModel::Click(double x, double y)
@{
 int cell_index;

 cell_index = environ->QueryCell(x, y);
 PopupCellRequester(cell_index);
@}
@end smallexample
This is the default Click function in @code{CAModel}, it pops up a
requester with the properties of the cell clicked on.

@page
@c -------------------------------------------------------------------------------
@deftypefun void CAEnviron::QueryScaleFactors (int @var{cell_index}, double &@var{sx}, double &@var{sy})


@exdent @b{Arguments}
@var{cell_index}@*
Specifies the cell. This parameter is only used
if, by some reason the cells are not the same size.

@var{sx}@*
Specifies the scaling factor in x-direction

@var{sy}@*
Specifies the scaling factor in y-direction

@exdent @b{Return value}
@code{sx} and @code{sy} are called by reference, and are therefore also
return values.

@exdent@b{Description} 
A vector in any direction of length one, multiplied with the scaling
factors are guaranteed to not go beyond the boundaries of the cell. We
needed some general way of declaring the size of a cell.  First we
decided to use the largest circle possible to draw inside a cell. This
did not work, because the units in x and y direction may not be the
same. Therefore we decided to use scaling factors. The scaling factors
should be used relative to the center of the cell.

Using scaling factors will make the angles wrong, but it is the best
way of doing it. The angles would not be exactly right anyway, because
a pixel on the monitor is not square. 

@exdent@b{Inheritance}
When implementing this function remember what @code{QueryPosition}
returned. This might not be the center.

@exdent @b{See also}
@code{QueryPosition}
@end deftypefun

@noindent
@b{Example}
@smallexample
void CASimpleSymbol::Draw(int Cell_index)
@{
 double sx, sy, center_x, center_y;
 x = 1;
 y = 1;
 env->QueryPosition(cell_index, center_x, center_y);
 env->QueryScalingFactors(cell_index, sx, sy);

 x *= sx;
 y *= sy;
 x += center_x;
 y += center_y;
 vis->DrawLine(center_x, center_y, x, y);
@}
@end smallexample
This example shows how to draw a line from the center of a cell and to (1,1).

@page
@c -------------------------------------------------------------------------------
@deftypefun void CAEnviron::SetPeriodic (Boolean @var{new_periodic})

@exdent @b{Arguments}
@var{new_periodic}@*
Specifies wether the boundaries are periodic.

@exdent @b{Return value}
None

@exdent@b{Description} 
Changes the setting of periodic boundaries (wrap-around). Default it is
set to FALSE, use this function to change it. This may also be set via
the Environ requester.

@exdent@b{Inheritance}
You will probably not need to inherit this function

@exdent @b{See also}
@ref{Introduction}
@end deftypefun

@page
@c -------------------------------------------------------------------------------

@deftypefun void CAEnviron::DrawGrid (CAVisual *@var{vis})

@exdent @b{Arguments}
@var{vis}@*
Specifies the visual to draw in.

@exdent @b{Return value}
None

@exdent@b{Description} 
If @code{draw_grid} is set, it will draw the boundaries around each
cell. This function should be called after each major redraw. If only
one cell is drawn you might want to save the time it takes to redraw the
whole grid. 

@exdent@b{Inheritance}
This function is abstract, and must be inherited. For some grid geometries it
is necessary to draw the boundaries for each cell. Others have straight
lines from one end of the coordinate system to the other, then it is
faster to draw the lines. This will reduce the number of X-calls,
remember that each X-call takes time.

@exdent @b{See also}
Nothing appropriate
@end deftypefun

@page
@c -------------------------------------------------------------------------------
@deftypefun void CAEnviron::SetupRequester (Req *@var{req})

@exdent @b{Arguments}
@var{Req}@*
Specifies the requester.

@exdent @b{Return value}
None

@exdent@b{Description} 
As noted in the chapter about the environ requester each subclass of
@code{CAEnviron} may add some wigets to the requester. This is the function
where this happens. It must be called before the requester is popped up.

@exdent@b{Inheritance}
Inherit it if you need to add anything to the requester. Make one or
more groups in the requester to add the widgets in. If you do not want
the widgets from your class's superclass, you do not need to call the
 superclass's function. Remember to do the same in @code{ReadRequester()}.

@exdent @b{See also}
@ref{The environ requester}, @code{ReadRequester()}
@end deftypefun
@noindent
@b{Example}
@smallexample
SimpleGrid::SetupRequester(Req *req)
@{
 Widget xtralabel, xtratoggler;
 CAGrid::SetupRequester(Req *req)
 req->AddGroup("xtravalues", formWidgetClass)
 xtralabel = req->AddWidget("label", "xtravalues", labelWidgetClass);
 xtratoggler = req->AddWidget("button", "xtravalues", togglerWidgetClass);

  XtVaSetValues(xtralabel,
	       XtNlabel, "A extra parameter",
	       NULL);

  XtVaSetValues(xtratoggler,
	       XtNlabel, "On/Off",
               XtNstate, TRUE,  //Should not be harcoded, rather set to
                                //the current value 
               XtNfromVert, xtralabel,
	       NULL);
@}
@end smallexample
This is an example of how to add two widgets to the requester. 
@page
@c -------------------------------------------------------------------------------

@deftypefun void CAEnviron::ReadRequester (Req *@var{req})


@exdent @b{Arguments}
@var{Req}@*
Specifies the requester.

@exdent @b{Return value}
None

@exdent@b{Description} 
This function reads the values set in the environ requester. It is
called when the requester is popped down.

@exdent@b{Inheritance} 
If you inherited @code{SetupRequester} you must also inherit this
funtion. Here you should read the values of the widgets you added. If
you dropped the superclass' @code{SetupRequester} function you
should also drop this.

@exdent @b{See also}
@ref{The environ requester}, @code{SetupRequester()}
@end deftypefun
@noindent
@b{Example}
@smallexample
SimpleGrid::ReadRequester(Req *req)
@{
  Boolean xtra_value
 Widget xtratoggler;
 CAGrid::ReadRequester(Req *req)
 xtratoggler = req->GetWidget("button", "xtravalues");

  XtVaGetValues(xtratoggler,
	       XtNlabel, "On/Off",
               XtNstate, &xtra_value,  
	       NULL);
@}
@end smallexample
This example reads the state of one widget into a local variable, it
should of course have done something useful with it.

@section Provided subclasses

We have provided a general subclass for all environs with fixed
geometry. This class a abstract class called @code{CAGrid}. We have also
provided a class for rectangular grids calles
@code{CARectangularGrid}.

@menu
* The CAGrid object::           
@end menu

@node The CAGrid object,  , CAEnviron Functions, CAEnviron Functions
@subsection The CAGrid object

Our intention is that @code{CAGrid} shall be the superclass of all
environs with fixed geometry (called grids). This is nesecary to make it
possible to change grid during runtime. We have added some functions to
this class that was not availabe in @code{CAEnviron}, most of these are
querying about neighbours. All new functions will be described in this
section.

We have also added two new variables in @code{CAGrid}, @code{rows} and
@code{cols}. Actually the whole consept of rows and columns are new in
@code{CAGrid}. How the rows and cols are inerperated is up to the
subclass. We have added some protected funcions that will take care of
this.

@subsubsection Public member functions

@page
@deffn constructor CAGrid::CAGrid (double new_x_min, double new_y_min,
	  double new_x_max, double new_y_max,
	  int new_cols, int new_rows)


@exdent @b{Arguments}
@var{new_x_min}@* @var{new_y_min}@* @var{new_x_max}@* @var{new_y_max}@*
Specifies the dimensions of the coordinate system (As in @code{CAEnviron}).

@var{new_cols}@*
@var{new_rows}@*
Specifies the number of rows and columns.

@exdent @b{Return value}
None.

@exdent@b{Description} 
This constructor works like the one in @code{CAEnviron}, but it also
sets @code{rows} and @code{cols}. Also here are there default values for
all parameters.

@exdent @b{See also}

@end deffn
@c -----------------------------------------------------------------------
@page

@deftypefun void CAGrid::SetRowsCols (int new_cols, int new_rows)

@exdent @b{Arguments}
@var{new_cols}@*
@var{new_rows}@*
Specifies the number of rows and columns.

@exdent @b{Return value}
None.

@exdent@b{Description} 
This function sets the number of rows and columns.

@exdent@b{Inheritance}
If your grid needs to re-calculate anything when the @code{rows} and
@code{cols} change, you must inherit this function, and do the
re-calculation here.

@exdent @b{See also}
@code{CAEnviron::CAEnviron()}
@end deftypefun
@page
@c -----------------------------------------------------------------------


@deftypefun int CAGrid::GetNumberOfCells (void)

@exdent @b{Arguments}
None.

@exdent @b{Return value}
The total number of cells.

@exdent@b{Description} 
This function uses @var{rows} and @code{cols} to calculate the total
number of cells. By default it returns @var{rows} * @code{cols}, but
this might not be correct for all grids. Therefore is it better to call
this function than to calculate it in the model.  This function should
be called in the constructor of your model and in
@code{CAModel::ReadEnvironRequester}.

@exdent@b{Inheritance}
If the default calculation is incorrect in the grid you are
implementing, you should inherit this function.

@exdent @b{See also}
@code{CAModel::ReadEnvironRequester()}, @code{CAModel::CAModel()}

@end deftypefun
@noindent
@b{Example}
@smallexample
void GameOfLife::ReadEnvironRequester()
@{
 CAModel::ReadEnvironRequester();
 CAGrid *grid = (CAGrid*) environ;
 if (cells != grid->GetNumberOfCells())
    @{
    AllocateCells(grid->GetNumberOfCells());
    @}
 Redraw();
@}
@end smallexample
This example allocates new cells if necessary. Note that you must caste
to a @code{CAGrid} pointer to use functions not definded in @code{CAEnviron}

@page
@c -----------------------------------------------------------------------

@deftypefun void CAGrid::QueryNeighbours(int cell_index, int levels, 
            index_array &neighbours)


@exdent @b{Arguments}
@var{cell_index}@*
The cell index.

@var{levels}@*
The number of levels to calculate neighbours.

@var{neighbours}@*
The @code{index_array} the neighbours shall be put in.

@exdent @b{Return value}
@code{index_array} are called by referanse, and are therefore also
return value.

@exdent@b{Description} 
This function returns the indexes to the neighbours to the cell. If
@var{level} is 1, the nearest neghbours are return. In
@code{CARectangularGrid} the levels are implemented like this:

@example
@group
   Neighbour levels:

   |2|2|2|2|2|    X = cell[cell_index]
   |2|1|1|1|2|    
   |2|1|X|1|2|
   |2|1|1|1|2|
   |2|2|2|2|2|
@end group
@end example

If the boundaries are non-periodic the cells on the edge will not have
neighbours on all sides. Then -1 will be used as cell_index.

@exdent@b{Inheritance}
You must inherit this function. 

It may be smart to convert @var{cell_index} to rows and columns. Im most
grids this will be the easiet way to calculate the neighbours. To
convert back to cell_index, use @code{RowCol2Index()} instead of checking
if the cell exists. 

@exdent @b{See also}
@ref{The index_array object}, @code{RowCol2Index()}

@end deftypefun
@noindent
@b{Example}
@smallexample
void GameOfLife::CountNeighbours(int *count)

 int cell_index;
 index_array neighbour;
 CAGrid *grid;
 LifeCell *current;
 
 grid = (CAGrid*) environ;
 
  grid->QueryNeighbours(cell_index, 1, neighbour);
  
  for(i=0; i<neighbour.GetSize();i++)
     @{
     if(neighbour.array[i]!=-1)
       @{
       current = (LifeCell*) cell[neighbour.array[i]]; 
       @}
     @}
@end smallexample
This example is from the Game of life model, and is casted therefore to
@code{LifeCell}, you must instead caste to the subclass of @code{CACell}
your model is using.

@page
@c -----------------------------------------------------------------------

@deftypefun void CAGrid::QueryCornerXY (int cell_index, 
double &corner_x, double &corner_y)

@exdent @b{Arguments}
@var{cell_index}@*
Specifies the cell.

@var{corner_x}@*
@var{corner_y}@*
The x and y coordinates of the corner, called by reference.

@exdent @b{Return value}
@var{corner_x}@*
@var{corner_y}@*
Called by referance, and therefore return values.

@exdent@b{Description} 
This function returns the position of a corner of a cell. It is only
used by models that draws something on the corner of the cells. The
corner returned is the same corner as returned in
@code{QueryCornerCells}. The grid specifies which corner (eg. lower left)

@exdent@b{Inheritance}
This is an abstract function and must be inherited. You may choose any
corner to return, as long as @code{QueryCornerCells} uses the same corner.

@exdent @b{See also}
@code{CAGrid::QueryCornerCells()}
@end deftypefun

@page
@c -----------------------------------------------------------------------

@deftypefun void CAGrid::QueryCornerCells(int cell_index, 
                                          index_array &corner_cells)

@exdent @b{Arguments}
@var{cell_index}@*
Specifies the cell.

@var{corner_cells}@*
An array of all cells located around this corner (including @var{cell_index})

@exdent @b{Return value}
@var{corner_cells}@*
Called by referance, and therefore return values.

@exdent@b{Description} 
This function returns all cells located around one of the corners on the
cell. This may be useful for models calculating vortexes. 

@exdent@b{Inheritance}
This is an abstract function and must be inherited. First you must
choose which corner to use (ie. lower left).  Start by @var{cell_index},
picking all the cells around the corner you chose turning clockwise.

@exdent @b{See also}
@code{CAGrid::QueryCornerXY}
@end deftypefun

@page
@c -----------------------------------------------------------------------

@deftypefun void CAGrid::QueryPolygon(int cell_index, polygon &poly)

@exdent @b{Arguments}
@var{cell_index}@*
Specifies the cell.

@var{poly}@*
Specifies the polygon.

@exdent @b{Return value}
@var{poly}@*
Called by referance, and therefore return values.

@exdent@b{Description} 
Puts each of the corners of the cell in @var{poly}. The polygon is given
in logical coordinatres ready to be drawn. This function is intended for
symbols that fills the whole cell (eg. @code{CAColorSymbol}).

@exdent@b{Inheritance}
This is an abstract function and must be inherited. 

@exdent @b{See also}
@ref{The polygon object}, @ref{The CASymbol object}
@end deftypefun

@page
@c -----------------------------------------------------------------------

@subsubsection Protected member functions

@deftypefun Boolean CAGrid::Inbounds (int row, int col)

@exdent @b{Arguments}
@var{row}@*
Specifies the row.

@var{col}@*
Specifies the column.

@exdent @b{Return value}
@code{TRUE} if the cell specified by @var{row} and @var{col} is inside the
boundaries of the grid, @code{FALSE}
otherwise. @code{periodic} is ignored.

@exdent@b{Description} 
   This procedure returns @code{TRUE} if the cell actually is within
   the borders of the grid                                   

@exdent@b{Inheritance}
This is an abstract function and must be inherited. 

@exdent @b{See also}
@ref{Introduction}
@end deftypefun
@page
@c -----------------------------------------------------------------------

@deftypefun int CAGrid::RowCol2Index(int row, int col)

@exdent @b{Arguments}
@var{row}@*
Specifies the row.

@var{col}@*
Specifies the rolomn.

@exdent @b{Return value}
The cell index.

@exdent@b{Description} 
This function translates from (row,col) to cell index. If the cell is
outside the boundaries of the grid and @var{periodic} is @code{FALSE}

@exdent@b{Inheritance}
This is an abstract function and must be inherited. 

@exdent @b{See also}
@ref{Introduction}, @code{Inbounds()]}

@end deftypefun

@c **********************************************************************
@c CHAPTER - The CACell object
@c **********************************************************************

@node The CACell object, The CAProperty object, The CAEnviron object, Top
@chapter The CACell object

@menu
* CACell Introduction::         
* CACell Functions::            
@end menu

@node CACell Introduction, CACell Functions, The CACell object, The CACell object
@section Introduction

All CA visualisations would consist of a number of "cells". The
representation and meaning of the cell concept might of course, differ,
but we have chosen to call it a "cell". 

The @code{CACell} object in itself is not usable for anything, each new
model must therefore provide its own cell class object derived from
@code{CACell}.

The @code{CACell} object should be where the state of one cell is defined. A
cell contains one or more @code{CAProperty} objcts, each describing one
part of the state. The subclasses of @code{CACell} must provide access
to the @code{CAProperty} objects used. We decided not to provide
standard access functions, because they would only make things more
complicated.

The easiest way to understand this class is to take a look at the
example. @ref{Game of life}.


@c -------------------------------------------------------------------------------
@c SECTION Introduction
@c -------------------------------------------------------------------------------

@node CACell Functions,  , CACell Introduction, The CACell object
@section Functions
All the functions are public and abstract.

@page
@deffn constructor CACell::CACell (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None.

@exdent@b{Description}
This does nothing, and this is probably what the constructor to the
subclass should do as well.
@exdent @b{See also}
@end deffn
@page

@deftypefun void CACell::SetupRequester (Req *@var{req})
@deftypefunx void CACell::ReadWidgets (Req *@var{req})
@deftypefunx void CACell::UpdateWidgetValue (Req *@var{req})

@exdent @b{Arguments}
@var{req}@*
Specifies the requester object.

@exdent @b{Return value}
None.

@exdent@b{Description} 
These functions control the Cell requester.

The @code{SetupRequester} function is used when the requester is set up.

The @code{ReadWidgets} function is used when the OK button is pressed

The @code{UpdateWidgetValue} function is used when the requester is already
set up, but is associated with another cell.

@exdent@b{Inheritance}
All procedures are abstract, so inheritance is required. Each procedure
has an equal in @code{CAProperty}, so all you have to do is to call this
procedure for all properties.

@exdent @b{See also}
@ref{The cell requester}, @ref{The Req object}

@end deftypefun
@noindent
@b{Example}
@smallexample
void LifeCell::SetupRequester(Req *requester)
@{
 alive.InitWidgets(requester, "Alive");
@}

void LifeCell::ReadWidgets(Req *requester)
@{
 alive.ReadWidgets(requester, "Alive");
@}

void LifeCell::UpdateWidgetValue(Req *requester)
@{
 alive.UpdateWidgetValue(requester, "Alive");
@}
@end smallexample
In this example there is only used one property.

@c **********************************************************************
@c CHAPTER - The CAProperty object
@c **********************************************************************

@node The CAProperty object, The CAVisual object, The CACell object, Top
@chapter The CAProperty object

@menu
* CAProperty Introduction::     
* Provided subclasses::         
* CADouble Functions::          
@end menu

@node CAProperty Introduction, Provided subclasses, The CAProperty object, The CAProperty object
@section Introduction

The state of a cell in a Cellular Automaton is determined by its
properties. A cell might have only one property, like the Boolean "Dead"
or "Alive" in the Game of Life model, or temperature and direction in
another model. Each property is represented by one or more widgets in a
@emph{cell requester}. The nature of each widget or group of widgets is
of course determined by the type of property we are dealing with. The
Life property of the Game Of Life model, would for instance have a
Boolean widget. To prevent you from having to deal too much with the X
widgets, we have provided a set of standard properties you can use in
your models. 

Each property could easily have been represented directly with an
integer or double, but then you would have to recreate the whole
requester each time you created a new @code{CACell} class. Since that
should be done for all new models, we decided to add the
@code{CAProperty} class to the class hierachy.

@node Provided subclasses, CADouble Functions, CAProperty Introduction, The CAProperty object
@section Provided subclasses

@menu
* CADouble::                    
* CABoolean::                   
@end menu

@node CADouble, CABoolean, Provided subclasses, Provided subclasses
@subsection CADouble

@code{CADouble} may be used whenever a floating point number is
needed. The default value is 0. The value may be set via @code{SetValue}
which takes a @code{double} as parameter. @code{GetValue} is used to
retrieve the value. It takes no parameter and returns the current value
as a @code{double}.

@code{CADouble} uses a dialog box to prompt for new value. The dialog box
includes a label with the referance name printed, and a textbox with the
current value. 

@node CABoolean,  , CADouble, Provided subclasses
@subsection CABoolean

@code{CABoolean} uses the @code{Boolean} datatype specified by X, this
can be either @code{TRUE} or @code{FALSE}. The state can be set with
@code{SetValue}, which takes a @code{Booloan} as parameter. If the state
is not @code{FALSE} it is set to @code{TRUE}. @code{GetValue} returns
either @code{TRUE} or @code{FALSE} depending of the state.  A toggle
button is used to set the state. The toggle button is an X11 widget
which looks like a button which is either inverted in colors or normal,
depending on the boolean state of the widget. This widget will use
@var{referance_name} as label on the toggle button.

If you only need to know how to use the functions in @code{CAProperty},
the examples in describing CACell @xref{The CACell object} will do,
otherwise just read on.

@c -------------------------------------------------------------------------------
@c SECTION Functions
@c -------------------------------------------------------------------------------

@node CADouble Functions,  , Provided subclasses, The CAProperty object
@section Functions
All the functions are public and abstract.

@page
@deffn constructor CAProperty::CAProperty (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None.

@exdent@b{Description}
This does nothing. The sublass constructor should initialize the state
to the default value eg. FALSE for CABoolean.

@exdent @b{See also}
Nothing appropriate
@end deffn
@page

@deftypefun void CAProperty::SetupRequester (Req *@var{req}, char *@var{identifier})
@deftypefunx void CAProperty::ReadWidgets (Req *@var{req}, char *@var{identifier})
@deftypefunx void CAProperty::UpdateWidgetValue (Req *@var{req}, char *@var{identifier})

@exdent @b{Arguments}
@var{req}@*
Specifies the requester object.

@var{req}@*
Specifies the identifier to use when referring to widgets.
@exdent @b{Return value}
None.

@exdent@b{Description} 
These functions controls the Cell requester. Use @var{identifier} as
referance when adding widgets to @var{req}. 

The @code{SetupRequester} function is used when the requester is set up.

The @code{ReadWidgets} function is used when the OK button is pressed

The @code{UpdateWidgetValue} function is used when the requester is already
set up, but is associated with another cell.

@exdent@b{Inheritance}
All procedures are abstract, so inheritance is reqired. 

@exdent @b{See also}
@ref{The cell requester}, @ref{The Req object}, @ref{The CACell object}

@end deftypefun
@c **********************************************************************
@c CHAPTER - The CAVisual object
@c **********************************************************************

@node The CAVisual object, The CASymbol object, The CAProperty object, Top
@chapter The CAVisual object

@c -------------------------------------------------------------------------------
@c SECTION Introduction
@c -------------------------------------------------------------------------------
@menu
* GOL Introduction::            
* The drawing area::            
* The text area::               
* The CAVisual menus::          
* CAVisual Functions::          
@end menu

@iftex
@sp 22
@special{psfile=GameOfLife1.eps vscale=40 hscale=40 hoffset=100 voffset=30}
@end iftex
@center{@i{The @code{CAVisual} window of the Game of Life model}}

@node GOL Introduction, The drawing area, The CAVisual object, The CAVisual object
@section Introduction
The @code{CAVisual} object is the "heart" of the graphics subsystem of
the Cellular Automaton visualization system. Here you'll find all the
functions you need (hopefully) to make the 2D graphics and textual
output which describes the cellular automaton.

You can use @code{CAVisual}'s member functions for most primitive 2D drawing
functions,such as lines, points, circles, ellipses and for complex ones
as polygons, rectangles, ellipses and arcs. Some of these shapes can be
either outlined or filled. The object also contains member functions for
formatted text output with various layout control unctions.

The object has a user defined color palette which you can modify either
by using member functions or by means of the @emph{color
requester}. This requester is a standard palette requester which allows
you to easily manipulate the colors of the cells and other drawing
objects of the simulation.

CAVisual actually consists of two class objects, @code{CAVisual} and
@code{CATextVisual}. The first one is for models with only graphic
representations, whereas the latter one is for models which need ordered
textual output which is not to appear in the graphics field. This output
will therefore appear in an area of itself separated from the graphics
area.  Thus we divide the simulation window of a @code{CATextVisual}
object in two parts, the @emph{graphics area} and the @emph{text
area}. We may therefore refer to CAVisual in plural.

The @code{CAVisual} window of the "game of life" model is shown in the
figure above with the graphics area on the left and a text area on the right.

The @code{CAVisual} object is contained within the @code{CAModel}
object, so that most of the member funtions of this class will actually
be called from this object. On the other hand, @code{CAVisual} also has a
pointer up in the hierarcy to the @code{CAModel} object, so that we can access
its public methods and properties.

The programming interface utilizes a set of @emph{taglist} functions,
which are described closer in the @emph{toolkit} chapter. This interface
makes it easy for you to specify the resources you need for the
@code{CAVisual} object without having to worry about initializing
resources you don't need as these already should be have quite decent
default values.


@c -------------------------------------------------------------------------------
@c SECTION The drawing area
@c -------------------------------------------------------------------------------
@node The drawing area, The text area, GOL Introduction, The CAVisual object
@section The drawing area
The drawing area exists in both the @code{CAVisual} and the
@code{CATextVisual} class objects. This is where you draw the cells,
grid, arrows, numbers and whatever else which may be interesting for
visualizing your cellular automaton.

@menu
* The coordinate system::       
* The color palette::           
* Double-buffering::            
* The drawing area tags::       
@end menu

@node The coordinate system, The color palette, The drawing area, The drawing area
@subsection The coordinate system
The drawing area contains a logical coordinate system which is
independent of the actual pixel coordinates. This is a normal cartesic
coordinate system, i.e it is increasing upwards and to the right instead
of downwards and right as in the screen coordinate system.  When using
the drawing functions, you always specify the coordinates relative to
the logical coordinate system.
@ifinfo
The default coordinate system has the dimesions x in [-2.0, 2.0] and y 
in [-2.0, 2.0]. 
@end ifinfo
@iftex
@tex
The default coordinate system has the dimesions $ x \in [-2.0, 2.0]$ and
$y \in [-2.0, 2.0]$.  
@end tex
@end iftex 

@menu
* Zooming::                     
@end menu

@node Zooming,  , The coordinate system, The coordinate system
@subsubsection Zooming
The coordinate system can be zoomed almost infinitely. By default the
middle mouse button is used for zooming. When pressing this button and
dragging, a zooming rectangle will occur. When releasing the button, the
drawing area will be zoomed in on the area bounded by the zooming
rectangle. When this happens, a redraw of the picture is needed, and
@code{CAVisual} calls the @code{CoordinatesChanged} method in
@code{CAModel}. By default, this method calls the @code{Redraw} method
in @code{CAModel}. If you want to make additional operations when a zoom
event occurs, you therefore have to override the
@code{CoordinatesChanged} method.

The @code{CAVisual} @emph{Control} menu has by default an item for zooming
out. By selecting this, the coordinate system will be zoomed out to the
original coordinates given in the taglist.

@node The color palette, Double-buffering, The coordinate system, The drawing area
@subsection The color palette
The CAVisual objects have a palette of max 256 colors. The actual number
of available colors depends on your X display. If you have a true color
display, you will have all 256 colors at your disposal, but if you have
an 8-bit display or lower, the visual object will grab hold of as many
colors as possible. Remember that some of the colors in an 8-bit display
are in use by the window manager and other programs running on the X
server, so if you need many colors, it might be wise to shut down all
other running programs.

You can think of the palette as an array of colors. Each color is made
out of three values, the red, green and blue (RGB) components of the given
color. The colors are referenced by the index in the palette array,
rather than by their RGB values. When creating a color, you must
therefore specify the index in  the color array where you want to put
this color, as well as the  RGB components of the color. When you have 
created a color, you can set the foreground drawing color to this 
particular color index. All subsequent drawing operations will then be 
made in this color. 

Two of the colors in the palette are considered special, and that is
color 0, and color 1. Color 0 is the @emph{background} color and 1 is
the @emph{foreground} color. The background of the drawing area will
always be drawn in color 0, and the grid (if any) will be drawn in the
foreground color (color 1).

@node Double-buffering, The drawing area tags, The color palette, The drawing area
@subsection Double-buffering
The @code{CAVisual} object has support for double-buffering. Double
buffering is used to make flicker-free animations. When using
double-bufering, we operate on two drawing @emph{pages}, the @emph{back
page} and the @emph{front page}. The idea is that you draw an animation
frame to the back page, which is invisible, and when the frame is
finished, this page is swapped with the front page and thus made
visible. This prevents the flickering you would have if you had to clear
the page between each animation frame.

When using double-buffering with CAVisual you use two functions,
@code{CurrentPageBack()} and @code{CurrentPageFront()}. For each frame
you draw, you must set the current page to be a back page with
@code{CurrentPageBack()}, and draw the frame. When the drawing is
finished, you use @code{CurrentPageFront()} to display the frame and set
the current drawing frame to be the front page.

To use double-buffering, you need support for it in the X server. The
CAVisual object currently supports two X11 double-buffering schemes. These
are the @b{Xmbuf} multibuffer-extension which was used in X11R5 and R6, and
@b{Xdbe}, the forthcoming double-buffer extension which will be
incorporated in the R6.1 versions and upwards. The object library can
only support one of these systems at a time, and must be compiled for
the type of double-buffering you use. If you use the @b{Xdbe} extension
the library must be compiled with the flag @code{MB_DBE} set, and
to use @b{Xmbuf} you have to compile with @code{MB_MULTIBUF}.

@node The drawing area tags,  , Double-buffering, The drawing area
@subsection The drawing area tags
The object's resources are specified with a set
of @emph{Tag/Value pairs}. The @emph{Tag} identifies the resource, and
the @emph{Value} specifies the value of this resource. These values may
be given with various data types depending on the character of the given
resource. 

The tag list @emph{must} be terminated by the special tag
@code{TAG_DONE}. If this is not done, a segmentation fault will occur. 
Each tag has a default value, and no tags have to be given in the
parameter list, except @code{TAG_DONE}.

The resources relevant for the drawing area is given in the
table below.  

@ifinfo
        Tag Name                Type            Default Value
        =========================================================
        VIS_Width               int             300
        VIS_Height              int             300
        VIS_Xmin                char *          "-2.0"
        VIS_Xmax                char *          "2.0"
        VIS_Ymin                char *          "-2.0"
        VIS_Ymax                char *          "2.0"
        VIS_DrawingMode         enum/spec       CAVisual::PIXMAP
        VIS_GfxScrollbars       Boolean         False

@end ifinfo
@iftex
@tex
\hskip 12pt
\vbox{\offinterlineskip
\halign{\strut \vrule \quad {\bf #} \quad 
        & \vrule \hfil \quad {\tt #} \hfil 
        & \quad \vrule \hfil \quad {\tt #}\quad\hfil\vrule\cr
\noalign{\hrule}
{TagName} & {\rm \bf Type} & {\bf Default Value}\cr
\noalign{\hrule}
    VIS\_Width          & int           & 300    \cr
    VIS\_Height         & int           & 300    \cr
    VIS\_Xmin           & char *        & "-2.0" \cr
    VIS\_Xmax           & char *        & "2.0"  \cr
    VIS\_Ymin           & char *        & "-2.0" \cr
    VIS\_Ymax           & char *        & "2.0"  \cr
    VIS\_DrawingMode    & enum/spec     & CAVisual::PIXMAP \cr
    VIS\_GfxScrollbars  & Boolean       & False  \cr
\noalign{\hrule}
}}

@end tex
@end iftex

@noindent @b{VIS_Width, VIS_Height:} These resources specifies the width
and height, in pixels, of the drawing area. The drawing area is always
oriented towards the upper left corner of the simulation window. 

@noindent @b{VIS_Xmin, VIS_Xmax, VIS_Ymin, VIS_Ymax:} These resources
specifies the dimensions of the coordinate system in which we are
drawing. They are actually floating-point values, but because of the
taglist interface, you have to give the values as strings, i.e. quoted.

@noindent @b{VIS_DrawingMode:} The graphics area can operate in two
drawing modes: @code{CAVisual::PIXMAP} and @code{CAVisual::WINDOW}. When the drawing mode is
PIXMAP, all drawing operations will be made both in the graphics area
window, and a pixmap. This ensures that the picture will be correctly
refreshed automatically when the window has been obscured by another window on the
screen. If the drawing mode is WINDOW, all drawing operations will be
made in the window only, and you will have to make an explicit redraw of
the picture if the it is covered by another window. 

@noindent @b{VIS_GfxScrollbars:} This boolean resource specifies whether
or not we want scrollbars around the graphics window.

@c -------------------------------------------------------------------------------
@c SECTION The text area
@c -------------------------------------------------------------------------------
@node The text area, The CAVisual menus, The drawing area, The CAVisual object
@section The text area
The text area is a box placed to the right of the graphics area. The
text area is divided into a predefined number of lines. You can write to
each line individually. The @code{CATextVisual} object provides methods for
text-only printing and a @code{printf()}-like formatted printing
function. Each line can have different fonts, weight, slant  and justification.

The width and height of the text box is constant once the window is
open. Therefore you must provide sufficient horizontal and vertical space
for the text when initializing the text area. 

The height of each line is determined by the height of the initial font
of each line and the line distance. So if you want to use a large font
in one of the lines you have to set this font as default to make enough
vertical space. Then you must scale down the font in the other lines. 

Remember that when using proportional fonts like for instance "Times",
it may be difficult to calculate the line width from the number of
characters in a line. 

@menu
* The text area tags::          
@end menu

@node The text area tags,  , The text area, The text area
@subsection The text area tags
In addition to the tags described for the graphics area, the
CATextVisual class object recognizes the following tags:

@ifinfo
        Tag Name                Type            Default Value
        =========================================================
        VIS_TextLines           int             12 
        VIS_LineDist            int             4  
        VIS_LineWidth           int             150   
        VIS_Fontname            char *          "fixed"
        VIS_Fontsize            int             10     
        VIS_Justification       enum/spec       CATextVisual::LEFT
        VIS_FontWeight          char            0               
        VIS_FontSlant           char            'r' 
        VIS_TxtScrollbars       Boolean         False

@end ifinfo
@iftex
@tex
\hskip 12pt
\vbox{\offinterlineskip
\halign{\strut \vrule \quad {\bf #} \quad 
        & \vrule \hfil \quad {\tt #} \hfil 
        & \quad \vrule \hfil \quad {\tt #}\quad\hfil\vrule\cr
\noalign{\hrule}
{TagName} & {\rm \bf Type} & {\bf Default Value}\cr
\noalign{\hrule}
    VIS\_TextLines      & int           & 12     \cr
    VIS\_LineDist       & int           & 4      \cr
    VIS\_LineWidth      & int           & 150    \cr
    VIS\_Fontname       & char *        & "fixed"\cr
    VIS\_Fontsize       & int           & 10     \cr
    VIS\_Justification  & enum/spec     & CATextVisual::LEFT \cr
    VIS\_FontSlant      & char          & 'r'    \cr
    VIS\_FontWeight     & char          & 0      \cr
    VIS\_TxtScrollbars  & Boolean       & False  \cr
\noalign{\hrule}
}}
@end tex
@end iftex

@noindent @b{VIS_TextLines:} This tag specifies how many lines of text
we want in the text area.

@noindent @b{VIS_LineDist:} Specifies the distance (in pixels) between
the text lines.

@noindent @b{VIS_LineWidth:} Specifies the width (in pixels) of a text line.

@noindent @b{VIS_Fontname:} This resource specifies the initial name of the font
to use on all lines in the text area, for example "Times". If the font
is not found, the default "fixed" will be used. This font should be
available on all X systems.

@noindent @b{VIS_Fontsize:} This specifies the initial point size of the font to
use in all the text lines. Note that this is the real point size and not
tenths of points as in other X font specifications.

@noindent @b{VIS_Justification:} This specifies the initial location of the text
in all the lines of the text field. This can be one of the following
three values: @code{CATextVisual::LEFT}, @code{CATextVisual::CENTER} or
@code{CATextVisual::RIGHT}. 

@noindent @b{VIS_FontSlant:} Specifies the initial slant for the font to
be used in the text lines. This value can be @code{'i'} for @i{italic}
or @code{'r'} for roman. 

@noindent @b{VIS_FontWeight:} Specifies the initial weight (thickness)
to use for the text lines. This value can be @code{'b'} for @b{bold}, or any
other value for medium.

@noindent @b{VIS_TxtScrollbars:} Specifies whether or not we want
scrollbars around the text area. 


@c -------------------------------------------------------------------------------
@c SECTION The CAVisual menus
@c -------------------------------------------------------------------------------
@node The CAVisual menus, CAVisual Functions, The text area, The CAVisual object
@section The CAVisual menus
The @code{CAVisual} objects have a menubar with two menus attached to it by
default. These menus are the @emph{File} menu and the @emph{Control}
menu. The File menu contains only one item, @emph{Close}. Selecting this
item, will close the CAVisual window and remove the parent model from
the model list. The Control menu has three items: @emph{Palette},
@emph{Settings} and @emph{Zooming}. When selecting the @emph{Palette} item, the
palette requester is popped up. This requester enables you to
interactively adjest the colors in the CAVisual palette. See @ref{The color requester} for further details. When selecting the @emph{Settings}
item, the @emph{Environ requester} is popped up. This requester
enables you to set various parameters for the grid/lattice structure in
the drawing window. See @ref{The environ requester} for further
details on this. When selecting the @emph{zoom out} item, the coordinate
system dimensions will be set to the default values set in the
taglist. See @ref{Zooming}.

The @code{menubar} object of CAVisual is public, and you can add menus and
menuitems to it by means of the @code{menu} and @code{menubar} member
functions. This is described in detail in @ref{Making Menus}.

@c -------------------------------------------------------------------------------
@c SECTION Functions
@c -------------------------------------------------------------------------------
@node CAVisual Functions,  , The CAVisual menus, The CAVisual object
@section Functions
Here you will find all the public member functions of the
@code{CAVisual} and @code{CATextVisual} objects. All functions which are
available in a @code{CAVisual} object are also available in a
@code{CATextVisual} object.

@menu
* CAVisual functions::          
* CATextVisual functions::      
@end menu

@node CAVisual functions, CATextVisual functions, CAVisual Functions, CAVisual Functions
@subsection CAVisual functions
@deffn constructor CAVisual::CAVisual (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None.

@exdent@b{Description}
This is the default constructor for the @code{CAVisual} object. If you use this
one, you have to initialize the object with the @code{Initialize()}
function, or the constructor described below.

@exdent @b{See also}
@code{Initialize()}
@end deffn
@page

@c -------------------------------------------------------------------------------

@deffn constructor CAVisual::CAVisual (CAModel @var{parent_model}, @var{@dots})

@exdent @b{Arguments}  
@var{parent_model}@*
The parent model of this object. i.e the model which needs to draw/write
in the window.

@var{@dots}@*
A variable length list of tag/value pairs describing resource values for
the object.@*

@exdent @b{Return value}
None.

@exdent @b{Description}
This constructor instantiates one @code{CAVisual} object with resources as
given in the parameter taglist. This function does the same as the
@code{Initialize} routine.

@exdent @b{See also}
@code{Initialize()}
@end deffn

@noindent
@b{Example}
@smallexample
 CAVisual *visual;

 visual = new CAVisual(this,
                       VIS_Width, 500,
                       VIS_Height, 500,
                       VIS_Xmin, "-2.5",
                       VIS_Xmax, "0.0",
                       TAG_DONE);
@end smallexample
This creates a drawing window of 500 by 500 pixels. The coordinate
system is from -2.5 to 0 in x-direction and -2.0 to 2.0 in y-direction.
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::Initialize (CAModel @var{parent_model}, @var{@dots})
@exdent @b{Arguments}
@var{parent_model}@*
The parent model of this object. i.e the model which needs to draw/write
in the window.

@var{@dots}@*
A variable length list of tag/value pairs describing resource values for
the object.

@exdent @b{Return value}
None.

@exdent@b{Description}
This function does the same as the constructor described above (except
that it does not instantiate a new @code{CAVisual} object of course).

@exdent @b{See also}
@code{CAVisual()}

@end deftypefun
@noindent
@b{Example}
@smallexample
 CAVisual visual;

 visual.Initialize(this,
                   VIS_Width, 500,
                   VIS_Height, 500,
                   VIS_Xmin, "-2.5",
                   VIS_Xmax, "0.0",
                   VIS_GfxScrollbars, True,
                   TAG_DONE);
@end smallexample
This creates a drawing window of 500 by 500 pixels. The coordinate
system is from -2.5 to 0 in x-direction and -2.0 to 2.0 in
y-direction. The graphics window has scrollbars in x- and y-direction.
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::GetCoordinateSystem (double &@var{ret_xmin}, double &@var{ret_ymin},
double &@var{ret_xmax}, double &@var{ret_ymax})

@exdent @b{Arguments}
@var{ret_xmin}@*
The minimum x value of the coordinate system, called by reference.  

@var{ret_ymin}@*
The minimum y value of the coordinate system, called by reference.  

@var{ret_xmax}@*
The maximum x value of the coordinate system, called by reference.  

@var{ret_ymax}@*
The maximum y value of the coordinate system, called by reference.  

@exdent @b{Return value}
All arguments are called by reference, so all arguments above are return
values.

@exdent @b{Description}
This function returns the boundaries of the default coordinate system in
the drawing area.

@exdent @b{See also}
Nothing appropriate

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun Widget CAVisual::GetGfxWidget (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
The X2Dview drawing widget of the current @code{CAVisual} class.

@exdent @b{Description}
This function returns the widget to which we are drawing. This may be
useful if you for instance are making a new requester and need a parent
widget for it.

@exdent @b{See also}
Nothing appropriate

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun int CAVisual::Popup (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
Zero for failure and non-zero for success.

@exdent @b{Description}
This function opens the @code{CAVisual} window and realizes all its widgets,
i.e the drawing and text windows and the menus. 

@i{Important!} This function must be run @emph{before} you can call any of
the drawing functions or color manipulation functions, like
@code{CAVisual::SetPaletteRGB}.

@exdent @b{See also}
@code{CAVisual::Popdown()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun int CAVisual::Popdown (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
Zero for failure and non-zero for success.

@exdent @b{Description}
This function closes the @code{CAVisual} window and destroys all the widgets.

@exdent @b{See also}
@code{CAVisual::Popup()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::ClearAll (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None

@exdent @b{Description}
This function clears the graphics window an sets its color to the
background color (color 0 in the palette). If the drawing mode is
@code{PIXMAP}, it also clears the pixmap.

@exdent @b{See also}
@code{SetPaletteRGB()}
 
@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::SetDrawable (int @var{new_drawable})
@exdent @b{Arguments}
@var{new_drawable}@*
The drawable type, either @code{CAvisual::PIXMAP} or @code{CAVisual::WINDOW}.

@exdent @b{Return value}
None

@exdent @b{Description}
This function sets the drawing type of all subsequent drawing operations
in the drawing window. If the drawing type is @code{PIXMAP}, all draing
operations will be made both in the window, and in a pixmap for
storage. When the window needs refreshing, the image stored in the
pixmap will be rendered in the window. If the drawing type is
@code{WINDOW}, drawing will only be made in the window, and when
obscured, an explicit redraw of the picture is needed.

@exdent @b{See also}
@code{CurrentPageFront()}, @code{CurrentPageBack()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::DrawPoint (double @var{x}, double @var{y})
@exdent @b{Arguments}
@var{x, y}@*
The logical x and y coordinates of the point to be drawn.

@exdent @b{Return value}
None

@exdent @b{Description}
This function draws a single pixel in the point specified in logical
coordinates. The color is the current drawing color.

@exdent @b{See also}
@code{SetDrawingColor()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------
@deftypefun void CAVisual::DrawLine (double @var{x1}, double @var{x2},double @var{y1},double @var{y2})

@exdent @b{Arguments}
@var{x1, y1}@*
The starting point of the line in logical coordinates.

@var{x2, y2}@* 
The end point of the line in logical coordinates.

@exdent @b{Return value}
None.

@exdent@b{Description}
This function draws a straight line between the two points given in the
parameter list. These points are given in logical coordinates. The line
will be drawn in the current drawing color.

@exdent @b{See also}
SetDrawingColor

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::DrawPolygon (polygon &@var{poly})
@exdent @b{Arguments}
@var{poly}@*
A pointer to a @code{polygon} object.

@exdent @b{Return value}
None

@exdent @b{Description}
This function draws a polygon in the current drawing color. The polygon
object is further described in the appendix @ref{Toolkit functions and classes}.

@exdent @b{See also}
@code{SetDrawingColor},@ref{The polygon object}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::DrawText (char *@var{text}, int @var{length}, double @var{x}, double @var{y})
@exdent @b{Arguments}
@var{text}@*
A null-terminated character string to be drawn in the drawing area.

@var{length}@*
The length in characters of the above string, including the null-terminator. 

@var{x,y}@*
The lower-left corner of the text string given in logical coordinates.

@exdent @b{Return value}
None

@exdent @b{Description}
This function renders a text string in the drawing window, using the
current drawing color and the current drawing font. The drawing font is
independent of the text area font, and the default is @code{"fixed"}.

@exdent @b{See also}
@code{SetDrawingColor()}, @code{SetDrawingFont()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::SetDrawingFont (char *@var{fontname}, char @var{weight}, char @var{slant}, int @var{size})
@exdent @b{Arguments}
@var{fontname}@*
Specifies the name of the font.

@var{weight}@*
Specifies the weight of the font.

@var{slant}@*
Specifies the slant of the font.

@var{size}@*
Specifies the point size of the font.

@exdent @b{Return value}
None.

@exdent @b{Description}
This function sets the drawing font. The drawing font is the font used
for text drawing in the drawing area, as opposed to the font used in the
text lines of the text area. @var{fontname} specifies the
string name of the font, e.g. "Times". @var{weight} can be 'b'
for @b{bold} typeface, and any other character for medium. @var{slant}
can be 'i' for @i{italic} text and 'r' for roman. @var{size}
is the point size of the font.
    
If the specified font is not found, this function defaults to @code{"fixed"}
which should be available on most X systems.

@exdent @b{See also}
@code{SetDrawingColor()}, @code{DrawText()}, @code{CATextVisual::SetFont()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------
@deftypefun void CAVisual::SetLineWidth (int @var{width})
@exdent @b{Arguments}
@var{width}@*
Specifies the line width in pixels.

@exdent @b{Return value}
None.

@exdent @b{Description}
This function sets the line width for all subsequent line drawing
functions, including @code{CAVisual::DrawCircle, DrawPolygon} and
@code{DrawEllipse}.

@exdent @b{See also}
@code{SetLineStyle()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::SetLineStyle (int @var{style})
@exdent @b{Arguments}
@var{width}@*
Specifies the line style. Possible values are @code{LineSolid},
@code{LineOnOffDash} and @code{LineDoubleDash}.

@exdent @b{Return value}
None.

@exdent @b{Description}
This function sets the line style for all subsequent line drawing
functions, including @code{CAVisual::DrawCircle, DrawPolygon} and
@code{DrawEllipse}. 

The possible values are:
@table @samp
@item LineSolid
Normal continous lines, drawn in current foreground color.

@item LineOnOffDash
Dotted lines, alternating between transparent and foreground color.

@item LineDoubleDash
Dotted lines, alternating between background and foreground color.
@end table

@exdent @b{See also}
@code{SetLineWidth()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::DrawCircle (double @var{cx}, double @var{cy}, double @var{radius})
@deftypefunx void CAVisual::FilledCircle (double @var{cx}, double @var{cy}, double @var{radius})
@exdent @b{Arguments}
@var{cx, cy}@*
This is the centre point of the circle given in logical coordinates.

@var{radius}@*
The radius of the circle given in logical coordinates.

@exdent @b{Return value}
None

@exdent @b{Description}
These functions draws a circle with the current drawing color in the
drawing area. The first one draws the perimeter only, while the other
one draws a filled disc.

@exdent @b{See also}
@code{SetDrawingColor()}, @code{DrawEllipse()}, @code{FilledEllipse()}
@end deftypefun
@page

@c -------------------------------------------------------------------------------
@deftypefun void CAVisual::DrawEllipse (double @var{cx}, double @var{cy}, double @var{rx}, double @var{ry})
@deftypefunx void CAVisual::FilledEllipse (double @var{cx}, double @var{cy}, double @var{rx}, double @var{ry})
@exdent @b{Arguments}
@var{cx, cy}@*
This is the centre of the ellipse given in logical coordinates.
@var{rx, ry}
These are the radii in x- and y-direction of the ellipse, given in
logical coordinates.

@exdent @b{Return value}
None

@exdent @b{Description}
These functions draw an ellipse in the drawing area with the current
drawing color. The first one draws only the perimeter, while the other
one draws a filled ellipse.

@exdent @b{See also}
@code{SetDrawingColor()}, @code{DrawCircle()}, @code{FilledCircle()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::DrawArc (double @var{x}, double @var{y}, double @var{width}, double @var{height}, int @var{angle1}, int @var{angle2})
@deftypefunx void CAVisual::FilledArc (double @var{x}, double @var{y}, double @var{width}, double @var{height}, int @var{angle1}, int @var{angle2})
@exdent @b{Arguments}
@var{x}, @var{y}@*
Specify the x and y coordinates, which are relative to the origin of the
drawing area and specify the upper-left corner of the bounding rectangle.

@var{width}, @var{height}@*
Specify the width and height, which are the major and minor axes of the arc.

@var{angle1}@*
Specifies the start of the arc relative to the three-o'clock position
from the center, in units of degrees.

@var{angle2}@*
Specifies the path and extent of the arc relative to the start of the
arc, in units of degrees.

@exdent @b{Return value}
None

@exdent @b{Description}
@code{DrawArc} draws a single circular or elliptical arc in the drawing area
with the current drawing color. 
An arc is specified by a rectangle and two angles.  The
center of the circle or ellipse is the center of the rectangle, 
and the major and minor axes are specified by the
width and height.  Positive angles indicate counterclockwise 
motion, and negative angles indicate clockwise
motion.  If the magnitude of angle2 is greater than 360
degrees, @code{DrawArc} truncates it to 360 degrees.

@code{FilledArc} fills the region closed by the path described by the 
specified arc and the two line segments joining the endpoints of the 
arc with the center point.

@exdent @b{See also}
@code{SetDrawingColor()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------
@deftypefun void CAVisual::DrawRectangle (double @var{x}, double @var{y}, double @var{width}, double @var{height});
@deftypefunx void CAVisual::FilledRectangle (double @var{x}, double @var{y}, double @var{width}, double @var{height});

@exdent @b{Arguments}
@var{x}, @var{y}@*
This is the upper-left corner of the rectangle given in logical
coordinates.

@var{width}, @var{height}@*
The width and height of the rectangle given in logical coordinates.
@exdent @b{Return value}
None

@exdent @b{Description}
The @code{DrawRectangle} function draws an outlined rectangle with the
current drawing color in the drawing area. @code{FilledRectangle} draws
a solid rectangle.

@exdent @b{See also}
@code{SetDrawingColor()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::CurrentPageFront (void)
@deftypefunx void CAVisual::CurrentPageBack (void)

@exdent @b{Arguments}
None

@exdent @b{Return value}
None

@exdent @b{Description}
These functions are used for double-buffering. The
@code{CurrentPageBack} function sets the current drawing page to be the
invisible back page. All subsequent drawing operations will be made to this
page. The @code{CurrentPageFront} function swaps pages so that the back
page is put to front and its contents are displayed. When swapping, the
contents of the prevous front page, i.e the new back page will be erased
so that no @code{ClearAll} calls are needed.

@exdent @b{See also}
@code{ClearAll}, @ref{Double-buffering}

@end deftypefun
@page
@c -------------------------------------------------------------------------------

@node CAVisual::SetPaletteRGB, CATextVisual functions, CAVisual functions, CAVisual Functions
@deftypefun void CAVisual::SetPaletteRGB (int @var{color}, int @var{red}, int @var{green}, int @var{blue})
@exdent @b{Arguments}
@var{color}@*
This is the index in the palette array for which we want to set/change
the color.

@var{red}, @var{green}, @var{blue}@*
These are the red, green and blue components of which the new color
consists. The values of these components are between 0 and 255.

@exdent @b{Return value}
None 

@exdent @b{Description}
This function sets the specified color in the palette. Each color
consists of three components of red, green and blue. Each of these
components range in value from 0 to 255, which yields a total of
@math{ 2^24 } possible colors. This is of course dependent on the type of
X display you have. If that many colors are not available, the RGB
values will be scaled so that the nearest color will be used. 

The colors placed at index 0 and 1 are the @emph{backgrond} and
@emph{foreground} colors respectively. If you change the background
color, the background of the drawing area will take this color the next
time you run the @code{ClearAll} function. 

@exdent @b{See also}
@code{SetDrawingColor()}, @code{ClearAll()}

@end deftypefun
@page
@c -------------------------------------------------------------------------------

@deftypefun void CAVisual::SetDrawingColor (int @var{color})
@exdent @b{Arguments}
@var{color}@*
Specifies an index in the color palette array.

@exdent @b{Return value}
None.

@exdent @b{Description}
This function sets the current drawing color to the color located at the
given index in the palette array. All subsequent drawing operations will
be made using this color. 

@exdent @b{See also}
@code{SetPaletteRGB()}

@end deftypefun
@page
@c -------------------------------------------------------------------------------

@deftypefun int CAVisual::PopUpColorRequester (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
zero for failure and non-zero for success.

@exdent @b{Description}
This function opens the palette requester. This requester enables you to
adjust the RGB values of all the colors in the palette array
interactively.  If the palette requester is
not instantiated, a new one will be made. This requester object will
remain in memory until the user presses the OK or Cancel buttons.

For further details see the section on the @ref{The color requester}.

@exdent @b{See also}
@ref{The color requester}, @code{SetPaletteRGB()}
@end deftypefun
@page
@c -------------------------------------------------------------------------------
@c SECTION CATextVisual functions
@c -------------------------------------------------------------------------------
@node CATextVisual functions,  , CAVisual functions, CAVisual Functions
@subsection CATextVisual functions
The following functions are only available in the CATextVisual object. 

@c -------------------------------------------------------------------------------

@deffn Constructor CATextVisual::CATextVisual (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
None

@exdent @b{Description}
This is the default constructor for the @code{CATextVisual} object. If
you use this one, you have to initialize the object with the
@code{Initialize()} function, or the constructor described below.

@exdent @b{See also}
@code{CATextVisual()}, @code{Initialize()}

@end deffn
@page

@c -------------------------------------------------------------------------------

@deffn Constructor CATextVisual::CATextVisual (CAModel *@var{parent_model}, @var{...})
@var{parent_model}@*
The parent model of this object. i.e the model which needs to draw/write
in the window.

@var{@dots}@*
A variable length list of tag/value pairs describing resource values for
the object.@*

@exdent @b{Return value}
None.

@exdent @b{Description}
This constructor instantiates one @code{CAVTextVisual} object with
resources as given in the parameter taglist. This function does the same
as the @code{Initialize} routine.

@exdent @b{See also}
@code{Initialize()}, @ref{The text area tags}
@end deffn

@noindent
@b{Example}
@smallexample
 CAVisual *visual;

 visual = new CATextVisual(this,
                       VIS_Width, 500,
                       VIS_Height, 500,
                       VIS_Fontname, "Times",
                       VIS_Fontsize, 14,
                       VIS_Justification, CATextVisual::CENTER,
                       TAG_DONE);
@end smallexample
This creates a drawing window of 500 by 500 pixels. The text area will
use the "Times" font with a size of 14 points, and all lines will be centered.
@page

@c -------------------------------------------------------------------------------

@deftypefun void CATextVisual::Initialize (CAModel *@var{parent_model}, @var{...})
@exdent @b{Arguments}
@var{parent_model}@*
The parent model of this object. i.e the model which needs to draw/write
in the window.

@var{@dots}@*
A variable length list of tag/value pairs describing resource values for
the object.

@exdent @b{Return value}
None.

@exdent@b{Description}
This function does the same as the constructor described above (except
that it does not instantiate a new @code{CATextVisual} object of course).

@exdent @b{See also}
@code{CATextVisual()}, @ref{The text area tags}

@end deftypefun
@noindent
@b{Example}
@smallexample
 CATextVisual visual;

 visual.Initialize(this,
                   VIS_Width, 500,
                   VIS_TxtScrollbars, True,
                   VIS_Fontname, "Courier",
                   VIS_Fontsize, 12,
                   VIS_TextLines, 20,
                   VIS_LineWidth, 200,
                   VIS_LineDist, 12,
                   TAG_DONE);
@end smallexample
This creates a drawing window of 500 by 300 pixels. The text area has 20
lines with a line distance of 12 pixels, and a width of 200 pixels. The font is 12pt
Courier. The text window has scrollbars in x- and y-direction.
@page

@c -------------------------------------------------------------------------------

@deftypefun void CATextVisual::Print (int @var{line}, char *@var{string})
@exdent @b{Arguments}
@var{line}@*
The line number on which we want to print the text. This number must be
between 0 and the value of @code{VIS_TextLines}.

@var{string}@*
A null-terminated character string we want to output.

@exdent @b{Return value}
None

@exdent @b{Description}
This function outputs a line of text on the specified line in the text
area. If the text string exceeds the length of the line, the
overshooting amount of text will disappear, so be sure to set enough
line width.

Observe that you do can not separate lines with @code{\n} as this
function operates on exactly one line.

@exdent @b{See also}
@code{Printf()}, @code{SetFont()}, @code{SetJustification()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CATextVisual::Printf (int @var{line}, char *@var{format}, @var{@dots})
@exdent @b{Arguments}
@var{line}@*
The line number on which we want to print the text. This number must be
between 0 and the value of @code{VIS_TextLines}.

@var{format}@*
This is a standard C @code{printf()}-format string.

@var{@dots}@*
A variable length list of variables to insert in the format string.

@exdent @b{Return value}
None

@exdent @b{Description}
This function outputs a formatted line of text on the specified line in
the text area. For further details on the format string, refer to the
@code{printf(3)} manual page. 

Observe that you do can not separate lines with @code{\n} as this
function operates on exactly one line.

@exdent @b{See also}
@code{printf(3)}, @code{Print()}, @code{SetFont()},
@code{SetJustification()}

@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun void CATextVisual::SetFont (char *@var{fontname}, char @var{weight}, char @var{slant}, int @var{size})
@deftypefunx void CATextVisual::SetFont (int @var{line}, char *@var{fontname}, char @var{weight}, char @var{slant}, int @var{size})
@exdent @b{Arguments}
@var{line}@*
The line number on which we want to change the font. This number must be
between 0 and the value of @code{VIS_TextLines}.

@var{fontname}@*
Specifies the name of the font.

@var{weight}@*
Specifies the weight of the font.

@var{slant}@*
Specifies the slant of the font.

@var{size}@*
Specifies the point size of the font.

@exdent @b{Return value}
None

@exdent @b{Description}
The @code{SetFont} method sets the font for the drawing area. If you specify a
line, only this line will be affected by the changes. If you do not
specify a line, the whole text area will use the new font.

@exdent @b{See also}
@code{SetJustification}, @ref{The text area tags}

@end deftypefun

@noindent
@b{Example}
@smallexample
 CATextVisual visual(parent_model, TAG_DONE);

 visual.SetFont("Courier", 0, 'r', 10);
 visual.SetFont(4, "Times", 'b', 'i', 12);
 visual.Print(4, "Bold italic Times font on line 4"); 
 visual.Print(5, "This line is in 10pts Courier");

@end smallexample

@c -------------------------------------------------------------------------------

@deftypefun void CATextVisual::SetJustification (int @var{just})
@deftypefunx void CATextVisual::SetJustification (int @var{line}, int @var{just})
@exdent @b{Arguments}
@var{line}@*
The line number on which we want to change the justification. This number must be
between 0 and the value of @code{VIS_TextLines}.

@var{just}
A justification value of either @code{CATextVisual::LEFT},
@code{CATextVisual::CENTER} or @code{CATextVisual::RIGHT}.

@exdent @b{Return value}
None

@exdent @b{Description}
This function sets the justification of the text area. The justification
can be either flush left, flush right or centered. If you specify a
line, only the given line will be affected. Otherwise, the whole text
area will use the new justification.

If this function is called within the scope of a derived class of
@code{CATextVisual}, you do not need to specify the class with
@code{CATextVisual::}.


@exdent @b{See also}
@code{SetFont}, @ref{The text area tags}

@end deftypefun
@noindent
@b{Example}
@smallexample
 CATextVisual visual(parent_model, TAG_DONE);

 visual.SetJustification(CATextVisual::CENTER);
 visual.SetJustification(4, CATextVisual::RIGHT);
 visual.Print(4, "Right");
 visual.Print(5, "And this line is centered");
@end smallexample
@page
@c -------------------------------------------------------------------------------

@deftypefun void CATextVisual::SetLineColor (int @var{fgcol}, int @var{bgcol})
@deftypefunx void CATextVisual::SetLineColor (int @var{line}, int @var{fgcol}, int @var{bgcol})
@exdent @b{Arguments}
@var{line}@*
The line number on which we want to change the line color. This number must be
between 0 and the value of @code{VIS_TextLines}.

@var{fgcol}@*
The palette number of the foreground color.

@var{bgcol}@*
The palette number of the background color.

@exdent @b{Return value}
None

@exdent @b{Description}
This function sets the colors of the text area. The colors must be
preset with @code{CAVisual::SetPaletteRGB}, or they will appear
black. If you specify a line number, only the given line will be
affected. Otherwise, the whole text area will use the new colors.

@exdent @b{See also}
@code{CAVisual::SetPaletteRGB()}.

@end deftypefun
@noindent
@b{Example}
@smallexample
 CATextVisual visual(parent_model, TAG_DONE);
 visual->Popup();
 visual->SetPaletteRGB(0, 255, 255, 255); //White
 visual->SetPaletteRGB(1, 0, 0, 0);       //Black
 visual->SetPaletteRGB(2, 255, 0, 0);     //Red

 visual.SetLineColor(1, 0);        // White text on black background.
 visual.SetJustification(4, 0, 2); // Black text on red background.
 visual.Print(4, "Black on red");
 visual.Print(5, "White on black");
@end smallexample
@page

@c -------------------------------------------------------------------------------
@c CHAPTER: The CASymbol object
@c -------------------------------------------------------------------------------
@node The CASymbol object, The Req object, The CAVisual object, Top
@chapter The CASymbol object

@menu
* CASymbol Introduction::       
* CASymbol Programming interface::  
@end menu

@node CASymbol Introduction, CASymbol Programming interface, The CASymbol object, The CASymbol object
@section Introduction

The use of @code{CASymbol} object is really optional. You may instead
make your drawings directly in @code{CAModel}, but we recomend that you
use a subclass of @code{CASymbol}. Here are some of our arguments:

@enumerate

@item It is easier to reuse the code to draw the symbol if it is
implemented as a class

@item If the implementation folows our guidelines you will make sure that it is
compatible with all grids.
@end enumerate

There are no standard @code{Draw} function in @code{CASymbol} because
the parameter list is not standard. Some symbols only need the color,
but other might need both color and direction on a arow. This leaves
@code{CASymbol} only the constructor and Initialize function.

@node CASymbol Programming interface,  , CASymbol Introduction, The CASymbol object
@section Programming interface

You may choose between initializing the symbol via the constructor or
via Initialize. The constructor has default values @code{NULL} to both
parameters. So if you do not specify both the @code{CAVisual} and the
@code{CAEnviron} object in the constructor, you must call Initialize.

Each subclass of @code{CASymbol} has its own version of Draw, each taking
different parameters. Lets look on two different uses of
@code{CAColoredEllipse}:
 
@noindent
@b{Example}
@smallexample
  CAColoredEllipse symbol;
  symbol.Initialize(visual, environ);
  symbol.Draw(2, 1);
@end smallexample

This example draws cell 2 with the default foreground color.  

@noindent
@b{Example}
@smallexample
  CASymbol *symbol;
  CAColoredEllipse *ellipse;
  symbol = new CAColoredEllipse(visual, environ;
  @dots
  ellipse = (CAColoredEllipse *) symbol
  ellipse->Draw(2, 1);
@end smallexample

This example does exactly the same as the first example, but it uses a
@code{CASymbol} pointer to hold the symbol. As you se we had to caste
the symbol to @code{CAColoredElipse} before we called the @code{Draw}
function. This is because Draw is not declared in @code{CASymbol}. This
example demonstrates why we chos not to include a @code{CASymbol}
pointer in @code{CAModel}.

@c -------------------------------------------------------------------------------
@c CHAPTER: The Req object
@c -------------------------------------------------------------------------------

@node The Req object, Making Menus, The CASymbol object, Top
@chapter The Req object

@menu
* Req Introduction::            
* Req A short tutorial::        
* Adding Callbacks::            
* Reading the requester::       
* Pop up the requester::        
* Use extra control widgets::   
@end menu

@node Req Introduction, Req A short tutorial, The Req object, The Req object
@section Introduction

As mentioned severeal places a general requester class is included in
the CASE package. The main concern when designing it was how to make a
simpel interface for cell requesters. It seems like the demands of the
cell requester is the same as other requesters. The window is split
in two regions, one containing the control buttons (Ok, cancel), and one
main area containing all other widgets.

One common thing for requesters defined under runtime is that there are
several subjects that need their own space of the window. This is solved
by dividing the main area in groups. In order to cut down the memory use
all widgets are referanced by names that can be hardcoded. This was done
because we did not want each cell to have pointers to parts of the
requesters.

@node Req A short tutorial, Adding Callbacks, Req Introduction, The Req object
@section A short tutorial

This is a walkthrough of the functions you use when making a requester
using the Req class.

@menu
* Initializing::                
* Adding groups::               
* Adding widgets::              
@end menu

@node Initializing, Adding groups, Req A short tutorial, Req A short tutorial
@subsection Initializing

The first you must do is to initialize the requester. This is done
either with the requester or the Initialize function. @code{Req::Req ()}
and @code{Req::Initialize}. In the example below we will use the the
default constructor. The first parameter to Initialize is a popped up
widget, we always use the toplevel widget of the control window. The
second is the name and title of the requester.

@b{Example}
@smallexample
 Req requester;
 requester.Initialize(toplevel, "Test requester");
@end smallexample

@node Adding groups, Adding widgets, Initializing, Req A short tutorial
@subsection Adding groups
If you want your widgets arrainged in groups
you must add the group first. A widget cannot be added first and thae
connected to a group.  Groups are added by AddGroup hwo takes two
parameters, the group name and the widget class. The widget class is
usually box or form.

@b{Example}
@smallexample
#include <X11/Xaw/Box.h>
 
 @dots

requester.AddGroup("MyGroup", boxWidgetClass);
@end smallexample

@node Adding widgets,  , Adding groups, Req A short tutorial
@subsection Adding widgets
Now we want to add two widgets in the group we created:

@b{Example}
@smallexample
#include <X11/Xaw/Label.h>
#include <X11/Xaw/Toggle.h>
 
 @dots
 Widget label_widget, toggle_widget;

 label_widget = requester.AddWidget("MyLabel", "MyGroup", labelWidgetClass);
 toggle_widget = requester.AddWidget("toggle", "MyGroup", labelWidgetClass); 

 XtVaSetValues(label_widget,
               XtNlabel, "Labeled",
               NULL);
@end smallexample

You may also add widgets that are not connected with a group, by using
NULL as reference name:

@b{Example}
@smallexample
#include <X11/Xaw/Label.h>
#include <X11/Xaw/Toggle.h>
 
 @dots
 Widget label_widget, toggle_widget;

 toggle_widget = requester.AddWidget("toggle", NULL, labelWidgetClass);
@end smallexample

@menu
* Adding Callbacks::            
@end menu

@node Adding Callbacks, Reading the requester, Req A short tutorial, The Req object
@section Adding callbacks

When you are using the @code{Req} class callbacks are not implemented
the usual way. @xref{Events and Callbacks}. Instead you need two
functions, each taking two parameters. The first should be a pointer to
a @code{Req} object, the second shoul be of @code{XtPointer} type. We
hope it is not confusing when we use another way to implement the
callback funtions here, but it is to make requesters easier to use.

@b{Example}
@smallexample
class AClass
@{
  static void Ok{Req *req, XtPointer data};   
  static void Cancel{Req *req, XtPointer data};
  void SetupRequester();
  Boolean state;
@}

void AClass::Setuprequester()
@{
  @dots
  requester.SetCallbacks(Ok, Cancel, (XtPointer) this);
@}
@end smallexample

Why you need the this pointer will be described later, for details see
@ref{Events and Callbacks}. 

@node Reading the requester, Pop up the requester, Adding Callbacks, The Req object
@section Reading the requester

When you press "Ok" or "Cancel" one of the callback functions are
called, then the requester is automaticly popped down. The @code{Cancel}
function is usually left empty, while the Ok function reads the values
from the requester. 

@b{Example}
@smallexample

void AClass::Ok{Req *req, XtPointer data}
@{
  Widget toggle_widget;
  Boolean value;
  AClass *aclass;
  aclass = (AClass *) data;
  
  toggle_widget = req->GetWidget("toggle", "MyGroup");
  XtVaGetValues(toggle_widget,
                XtNstate &aclass->state,
                NULL);
@}
@end smallexample

There are several things to notice in this example. The most important
is that we always uses a pointer to access the class members. This is
because the function is declared static and is not asociated with a
object. The data parameter is the same as what was given as the third
parameter in @code{SetCallbacks}. Since this was the @code{this} pointer
to the object that sat up the requester, this is also a pointer to the
same object.

@code{GetWidget} takes two arguments, the first is the string name to hte
widget, the second is the referance name to the group that the widget
belongs to. If the referance name is @code{NULL}, the widget is assumed to not
belong to any group.

@node Pop up the requester, Use extra control widgets, Reading the requester, The Req object
@section Pop up the requester

Now you may pop up the requester using @code{Popup}. There are three
member functions conserning popping the requester up and down:
@code{Popup}, @code{Popdown} and @code{PoppedUp}. @code{Popup} pops up
the requester, this is the only function that you must
use. @code{Popdown} pops down the requester, this is not nesecary,
because it is done automatically when Ok or Cancel is chosen. PoppedUp
returns @code{TRUE} if the requester is popped up, and @code{FALSE}
otherwise.

@node Use extra control widgets,  , Pop up the requester, The Req object
@section Use extra control widgets

You may add widgets that will ge placed next to the "Cancel"
button. These are called control widgets and usually buttons
(e.g. help). Lets look at an example using a help button.

@b{Example}
@smallexample
static void AClass::Help(Widget w, XtPointer data, XtPointer garbage)
@{
  AClass *aclass;
  aclass = (AClass *) data;
  aclass->DoSomething();
@}

 @dots

  Widget help;
  help = requester.AddControl("Help", commandWidgetClass);

  XtAddCallback(w, Help, this);
@end smallexample

As you see you must manually add the callback function to widgets. Since
most control widgets are buttons you rearly needs a pointer to a
control. But we have provided a @code{GetControl} funtion that returns
the widget. It works like @code{GetWidget}, but looks in the control
area, and does not need the referance name.

@b{Example}
@smallexample
  Widget help
  help = requester.GetControl("Help");
@end smallexample


@c **********************************************************************
@c CHAPTER: Creating menus
@c **********************************************************************
@node Making Menus, Toolkit functions and classes, The Req object, Top
@chapter Making Menus
@menu
* Menus Introduction::          
* Menus A short tutorial::      
* Example Functions::           
@end menu

@node Menus Introduction, Menus A short tutorial, Making Menus, Making Menus
@section Introduction

The Cellular Automata package also includes a simple scheme for making
drop-down menus. It consists of two class objects; @code{menu} and
@code{menubar}. The idea is that you make one menubar, attached to a
window (Widget), and then you add as many menus as you like. Each can
have as many items you want, and each item is linked to a
@emph{callback function}.

@node Menus A short tutorial, Example Functions, Menus Introduction, Making Menus
@section A short tutorial
This is a walkthrough of the functions you use when making a menubar
with menus. At the end of this section is a more complete example source.

@menu
* Create the menubar::          
* Add menus::                   
* Fill in the menu items::      
* Complete example::            
@end menu

@node Create the menubar, Add menus, Menus A short tutorial, Menus A short tutorial
@subsection Create the menubar

First you instantiate a @code{menubar} object. You must provide a
@code{Widget} as argument to the constructor or the
@code{Initialize} function. This Widget is the window, to which you 
want to attach the menubar. 

@b{Example}
@smallexample
 menubar menus;

 form = XtVaCreateManagedWidget("form", formWidgetClass, toplevel,
                                NULL);
 menus.Initialize(form);
@end smallexample

@node Add menus, Fill in the menu items, Create the menubar, Menus A short tutorial
@subsection Add menus
The next thing you do is to start adding menus to this menubar. We
want a file menu and an options menu. It goes like this:

@smallexample
 menu file_menu;

 file_menu = menus.AddMenu(``File'');
 options_menu = menus.AddMenu(``Options'');
@end smallexample

@node Fill in the menu items, Complete example, Add menus, Menus A short tutorial
@subsection Fill in the menu items
Now we want some items on our two menus. Each menu item is attached to a
callback function which must be declared @code{static}, with three
arguments: A @code{Widget}, an @code{XtPointer} to the data which should
be passed, and a second @code{XtPointer} which usually is unused. For
more on callbacks, see @ref{Events and Callbacks}.

@b{Example}
@smallexample
 file_menu.AddItem("Open", OpenFile, (XtPointer)"Open");
 file_menu.AddItem("Save", SaveFile, (XtPointer)"Save");
 file_menu.AddItem("About", About, (XtPointer)"About");
 file_menu.AddItem("Exit", Exit, (XtPointer)NULL);

 options_menu.AddItem("Simulation", SimulationOptions, (XtPointer)NULL);

 @dots

 static void OpenFile(Widget w, XtPointer data, XtPointer garbage)
 @{
 char *string = (char *)data;

 cout << "You selected " << string;
 @}

 static void Exit(Widget w, XtPointer data, XtPointer garbage)
 @{
 exit(0);
 @}
@end smallexample

That's all there is to it, really.

@node Complete example,  , Fill in the menu items, Menus A short tutorial
@subsection Complete example

Here is a complete example of making menus with these objects. In the
context of Cellular Automata models, you usually would have the
widgets and the other Xt stuff made for you already, but this is meant
to be a more general example.

@smallexample
/*
** menutest.C: test of menu objects
*/

#include <iostream.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Form.h>
#include <menu.h>

static void Open(Widget w, XtPointer data, XtPointer dill);
static void Exit(Widget w, XtPointer data, XtPointer dill);
static void Dill1(Widget w, XtPointer data, XtPointer dill);
static void Dill2(Widget w, XtPointer data, XtPointer dill);

int main(int argc, char **argv)
@{
 XtAppContext ac;
 Widget toplevel, form;
 menubar menus;
 menu file_menu, dill_menu;
 
 toplevel = XtVaAppInitialize(&ac, "MenuTest", NULL, 0, 
                              &argc, argv, NULL, NULL);
 form = XtVaCreateManagedWidget("mainwin", formWidgetClass, 
                                toplevel, NULL);

 menus.Initialize(form);

 file_menu = menus.AddMenu("File");

 file_menu.AddItem("Open", (XtPointer)Open, (XtPointer)"open data");
 file_menu.AddItem("Exit", (XtPointer)Exit, (XtPointer)NULL);

 dill_menu = menus.AddMenu("Dill");

 dill_menu.AddItem("Dill1", (XtPointer)Dill1, (XtPointer)"dill1 data");
 dill_menu.AddItem("Dill2", (XtPointer)Dill2, (XtPointer)NULL);

 XtRealizeWidget(toplevel);

 XtAppMainLoop(ac);
@}

void Open(Widget w, XtPointer data, XtPointer dill)
@{
 char *text = (char *)data;
 
 cout << "open " << text << endl;
@}

void Exit(Widget w, XtPointer data, XtPointer dill)
@{
 cout << "Bye!\n"; 
 exit(0);
@}

void Dill1(Widget w, XtPointer data, XtPointer dill)
@{
 char *text = (char *)data;
 
 cout << "dill1 " << text << endl;
@}

void Dill2(Widget w, XtPointer data, XtPointer dill)
@{
 cout << "dill2\n";
@}
@end smallexample

@c -------------------------------------------------------------------------------

@menu
* Functions::                   
@end menu

@node Example Functions,  , Menus A short tutorial, Making Menus
@section Functions
@deffn Constructor menu::menu (void)
@deffnx Constructor menu::menu (Widget @var{parent}, char *@var{title})
@exdent @b{Arguments}
@var{parent}@*
The parent widget to which the menu is associated.

@var{title}@*
The title of the menu.

@exdent @b{Return value}
None

@exdent @b{Description}
The first constructor declares a menu object, and does nothing more with
it. This is the one you should use when creating menus.

The second constructor adds a menu with title @var{title} to a
widget. You should never use this function directly, as this constructor
is called via the @code{menubar::AddMenu()} method.

@exdent @b{See also}
menubar::AddMenu()
@end deffn
@page

@c -------------------------------------------------------------------------------

@deftypefun Widget menu::AddItem (char *@var{title}, XtCallbackProc @var{function}, XtPointer @var{data})
@exdent @b{Arguments}
@var{title}@*
This is the title of the menu item.

@var{function}@*
A callback function to run when this item is selected.

@var{data}@*
A variable to be passed as data to the callback function.

@exdent @b{Return value}
The widget of the menu item.

@exdent @b{Description}
This function adds an item to the menu. The callback function provided
will be run when this item is selected from the menu, and the data
provided in @var{data} will be passed.

@exdent @b{See also}
@code{menubar::AddMenu()}, @ref{Events and Callbacks}
@end deftypefun
@page

@c -------------------------------------------------------------------------------

@deftypefun Widget menu::GetButtonWidget (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
The widget of the menu button.

@exdent @b{Description}
This function returns the menu button widget, i.e. the widget the user
clicks on to open a menu. This may be useful if you are adding widgets
yourself, and want to place them relative to the menu.

@exdent @b{See also}
Nothing appropriate
@end deftypefun
@page

@c -------------------------------------------------------------------------------
@deffn Constructor menubar::menubar (void)
@deffnx Constructor menubar::menubar (Widget @var{parent})
@exdent @b{Arguments}
@var{parent}@*
The parent widget of the menubar.

@exdent @b{Return value}
None

@exdent @b{Description}
The first constructor does nothing but declare a menubar object. The
second one creates the menubar widget. To do this, it needs a parent
widget to be assiciated with to (don't we  all :-). This would typically
be the toplevel widget of the window to which the menubar is attached.

@exdent @b{See also}
@code{menubar::Initialize()}

@end deffn
@page
@c -------------------------------------------------------------------------------

@deftypefun Widget menubar::Initialize (Widget @var{parent})
@exdent @b{Arguments}
@var{parent}@*
The parent widget of the menubar.

@exdent @b{Return value}
The widget of the menubar.

@exdent @b{Description}
This function does the same as the second constructor to the menubar
class, except that it also returns the widget which will contain the
menus. It should be used when the menubar is declared as a pointer and
not instantiated directly.

@exdent @b{See also}
@code{menubar::menubar()}
@end deftypefun
@page
@c -------------------------------------------------------------------------------

@deftypefun menu menubar::AddMenu (char *@var{title})
@exdent @b{Arguments}
@var{title}@*
The title of the menu.

@exdent @b{Return value}
A menu object associated with the menubar.

@exdent @b{Description}
THis function adds a menu to the menubar. The menu object which is
returned will be used for adding items to the menu. The menu must not be
used if it has not got any items in it.

@exdent @b{See also}
@code{menu::AddItem()}, @code{menu::menu()}.
@end deftypefun
@page
@c -------------------------------------------------------------------------------

@deftypefun Widget menubar::GetWidget (void)
@exdent @b{Arguments}
None

@exdent @b{Return value}
The widget of the menubar.

@exdent @b{Description}
This function returns the menubar widget. It can be useful when adding
widgets in a window which you want to place relative to the menubar.

@exdent @b{See also}
@code{menu::GetMenuWidget()}.

@end deftypefun
@page

@c -------------------------------------------------------------------------------
@c CHAPTER: Toolkit functions and classes
@c -------------------------------------------------------------------------------
@node Toolkit functions and classes, X2DviewWidgetClass, Making Menus, Top
@chapter Toolkit functions and classes

While developing CASE we needed some classes and functions to small to
put in a file alone. We called the file "toolkit", therefore we also
created a chapter in this document for this classes and function. The
@code{polygon} class and the index_array are just made to control dynamically
allocated arrays. They could very well have been implemented better,
but we did not have the time to make anything fancy. They were just made
so you would not have to think about allocating and deleting pointers some
places.

@menu
* The polygon object::          
* The index_array object::      
* The AddBitmapToWidget function::  
* The taglist interface::       
@end menu

@section The CAModelList object

The @code{CAModelList} is implemented as a list of
@code{CAModel}objects It is used by @code{CAApp} to keep all active
models in. Each @code{CAModelList} object contains a pointer to a
@code{CAModel} object, it also contains a pointer to the next
@code{CAModelList} object.

@code{CAModelList} also keeps a pointer to the current
@code{CAModelList} to make it possible to traverse the list. This is
moved either by @code{Reset} or @code{Next}. 

@subsection Functions

@page
@deffn constructor CAModelList::CAModelList (void);

@exdent @b{Arguments}
None.

@exdent @b{Return value}
None.

@exdent@b{Description}
This is the default constructor, it initializes current as this, and
next as @code{NULL}.

@exdent @b{See also}
@ref{The CAModel object}
@end deffn
@c -----------------------------------------------------------------------
@page

@deftypefun void CAModelList::Add (CAModel *new_model);

@exdent @b{Arguments}
@var{new_model}@*
A pointer to the model that shall be added.

@exdent @b{Return value}
None.

@exdent@b{Description} 
This function adds a model to the list, this is done by creating a new
instance of @code{CAModelList} and setting its @code{model} pointer to
@var{new_model}. The new @code{CAModelList} object will be placed first
in the list.

@exdent @b{See also}

@end deftypefun
@page
@c -----------------------------------------------------------------------

@deftypefun int CAModelList::Remove (CAModel *dead_meat);

@exdent @b{Arguments}
@var{dead_meat}@*
A pointer to the model that shall be Removed.

@exdent @b{Return value}
If @var{dead_meat} is found it returns 1, otherwise it returns 0.

@exdent@b{Description} 
This function searches recursively through the list for
@var{dead_meat}. If it is found it will be removed and deleted.

@exdent @b{See also}

@end deftypefun
@page
@c -----------------------------------------------------------------------

@deftypefun void CAModelList::Reset (void)


@exdent @b{Arguments}
None

@exdent @b{Return value}
None

@exdent@b{Description} 
Restes @code{current} to the first model in the list.

@exdent @b{See also}
@code{CAModelList::Next()}
@end deftypefun
@page
@c -----------------------------------------------------------------------

@deftypefun CAModel *CAModelList::Next (void)

@exdent @b{Arguments}
None

@exdent @b{Return value}
A pointer to the current model-

@exdent@b{Description} 
This function returns the current model and moves @code{current} to rhe
next model. If the current model is the last, @code{NULL} is
returned. Use this function to traverse the list.
@code{CAModelList::Reset()}
@exdent @b{See also}

@end deftypefun

@noindent
@b{Example}
@smallexample
 CAModelList model_list
 CAModel *current
 @dots
 model_list.Reset();
 while (current = model_list->Next())
    {
    currett->Update();
    }
@end smallexample
This example traverses the whole list and calls @code{Update} for each
model.

@node The polygon object, The index_array object, Toolkit functions and classes, Toolkit functions and classes
@section The polygon object

This class is made to hold a polygon, wich is a number of points. The
main concern when implementing this class was were are the memory for
the neighbour array going to be implemented. We did not want
@code{CAGrid} to do this, because then @code{CAModel} would have to
dealloc memory it had not allocadet. Neither could @code{CAModel}
allocate the memory, because that class had no information about how
much memory should be allocated. The solution vas this class.

@menu
* Toolkit Programming interface::  
@end menu

@node Toolkit Programming interface,  , The polygon object, The polygon object
@subsection Programming interface

Both the @code{x} and @code{y} arrays are public, so you may access them
directly. Before you do so, you must specify how much memory the array
will use, this is either don in the constructor, or in @code{SetSize}. If you
use @code{SetSize} multiple times, the arrays will be deallocated firs, and
then reallocated. @code{Getsize} returns the the size of the arrays.

@b{Example}
@smallexample
  double x, y;
  polyon poly;
  poly.SetSize(4);
  poly.x[0] = 1.1;
  poly.y[0] = 2.2;
  @dots  

  x = poly.x[2];
  y = poly.y[2];

@end smallexample
 
@node The index_array object, The AddBitmapToWidget function, The polygon object, Toolkit functions and classes
@section The index_array object

This class contains an integer array. The array is accessible through
the @code{Array} function, wich returns a pointer to the array. Like the
polygon class you may set the size eithe throug the constructor, or the
@code{SetSize} function. @code{GetSize} will get the size allocated in
the array.

@page
@node The AddBitmapToWidget function, The taglist interface, The index_array object, Toolkit functions and classes
@section The AddBitmapToWidget function

@deftypefun void AddBitmapToWidget (Widget w, int width, int height, char *data)
@exdent @b{Arguments}
@var{w}@*
Specifies the widget.

@var{width}@*
Specifies the with of the bitmap.

@var{height}@*
Specifies the height of the bitmap.

@var{data}@*
This is the bitmap itself.

@exdent @b{Return value}
None

@exdent @b{Description}
This function adds a bitmap to a widget. The widget must be popped up
(realized), or you will get a X-error. This function is used in the
control window to add the play an pause buttons. 


@exdent @b{See also}


@end deftypefun

@b{Example}
@smallexample
#include <play.xbm>

 play = XtVaCreateManagedWidget("play", commandWidgetClass, form,
				NULL);

//Pop up the window
 AddBitmapToWidget(play, play_width, play_height, (char *)play_bits);
@end smallexample

This example is cut from @file{CAApp.C}, @code{play_with}, @code{play_height}
and @code{play_bits} are defined in @file{play.xbm}. You must use the standard
bitmap format for X (X-bitmap), we used Xfig to draw our bitmaps.


@c -------------------------------------------------------------------------------
@c SECTION
@c -------------------------------------------------------------------------------

@node The taglist interface,  , The AddBitmapToWidget function, Toolkit functions and classes
@section The taglist interface
You'll probably have noticed that some of the objects in the CA
library uses a tag/value based programming interface. This is built
around a class object we have called @code{TagList}. This object
should be easy to use to implement similar programming interfaces for
derived class objects in your Cellular Automaton.

The idea behind the taglist object is that you can make functions with
a variable set of parameters, all of which have been given default
values. This means that when using a function with this interface you
you can specify the resources you need to change, and the rest will be
given default values.

Take for example, the CAVisual object. If you don't specify anything
for VIS_Width or VIS_Height, these resources will be given the default
values of 300 pixels.

The procedure for making a TagList interface for a function generally
goes like this:

@itemize @bullet
@item Make an enumerated list of tags. A tag is an identifier for a
given resource, like for instance @code{VIS_Width}. The enumeration
list should start on 1 and end with a tag identifying the number of
tags given for this function or object.

@item Make a default taglist. You can either use the constructor
@code{TagList(number_of_tags, ...)} which takes the number of tags and
the default tag/value pairs as parameters, or the @code{Initialize}
function which takes the same set of parameters. If you use this last
function, you must first use the default constructor to instantiate
the @code{TagList} object.

@item Define the function with the wanted set fo parameters. The
taglist itself would be defined as a @code{var_arg} list. (See man page for
further details). 

@item To set resources given in the parameter list you iterate through
the @code{var_arg} list and exttact the Tag and the Value (in that
order) until you reach the @emph{TAG_DONE} tag which terminates the
parameter list. You can then use the @code{SetValue} member function
to store the new tag value on the correct spot in the taglist.

@item To extract a given tag value from the taglist you use the
@code{GetValue} member function.

@end itemize
@page

@menu
* Taglist Functions::           
@end menu

@node Taglist Functions,  , The taglist interface, The taglist interface
@subsection Functions

@c ----------------------------------------------------------------------
@deffn Constructor TagList::TagList (void) 
@exdent @b{Arguments}
None

@exdent @b{Return value}
None

@exdent @b{Description}
This is the constructor for the TagList object. It does nothing except
declare a TagList object, and you will have to use the @code{InitTags} method
described below to set up the default taglist.

@exdent @b{See also}
@code{TagList::InitTags()}

@end deffn
@page
@c ----------------------------------------------------------------------
@deftypefun void TagList::InitTags (int @var{n_tags}, @var{@dots})
@exdent @b{Arguments}
@var{ntags}@*
The number of tags in the default tag list.

@var{@dots}@*
a varable length list of tag/value pairs.

@exdent @b{Return value}
None

@exdent @b{Description}
This function initializes the taglist with the tags and values the
initial list should have. First you specify how many tags you want in
the list, and then you provide the default list with tags and their values.

@exdent @b{See also}
@code{TagList::SetValue()}, @code{TagList::GetValue()}
@end deftypefun

@noindent
@b{Example}
@smallexample

  enum
     {
     VIS_Width,
     VIS_Height,
     VIS_Xmin,
     VIS_Xmax,
     VIS_Ymin,
     VIS_Ymax,
     CAVIS_TAGS
     };

  TagList taglist;

  taglist.InitTags(CAVIS_TAGS,
                   VIS_Width,         300,
                   VIS_Height,        300,
                   VIS_Xmin,          "-2.0",
                   VIS_Xmax,          "2.0",
                   VIS_Ymin,          "-2.0",
                   VIS_Ymax,          "2.0");


@end smallexample

This example declares a list of tags terminated by a tag which equals
the number of tags in the list. Then it initializes those tags with
variuos values.
@page

@c ----------------------------------------------------------------------
@deftypefun int TagList::SetValue (ULONG @var{tag}, ULONG @var{value}) 
@exdent @b{Arguments}
@var{tag}@*
The tag for which we want to set the value

@var{value}@*
The new value of the given tag.

@exdent @b{Return value}
Zero for failure and non-zero for success.

@exdent @b{Description}
This function associates a given tag in the taglist with the given
value. If the given tag is not found, 0 is returned.

@exdent @b{See also}
@code{TagList::InitTags()}, @code{TagList::GetValue()}.
@end deftypefun
@page

@c ----------------------------------------------------------------------

@deftypefun ULONG TagList::GetValue (ULONG @var{tag}) 
@exdent @b{Arguments}
@var{tag}@*
The tag for which we want to get the value

@exdent @b{Return value}
The value associated with the given tag.

@exdent @b{Description}
This function retrieves the value which is associated with the given tag
in the taglist. If the tag is not found, a warning is printed on
standard output. The value returned is ULONG an (@code{unsigned long})
integer value, and should therefore be casted to the proper type of the
variable to which we are assigning the value.

@exdent @b{See also}
@code{TagList::InitTags()}, @code{TagList::SetValue()}.
@end deftypefun
@page

@c **********************************************************************
@c APPENDIX: X2Dview Widget
@c **********************************************************************

@node X2DviewWidgetClass, bibliography, Toolkit functions and classes, Top
@appendix X2DviewWidgetClass

@menu
* X2DviewWidgetClass Introduction::  
* Resources::                   
@end menu

@node X2DviewWidgetClass Introduction, Resources, X2DviewWidgetClass, X2DviewWidgetClass
@section Introduction

The X2Dview widget is an X11 >= R5 compatible Widget for drawing and
animation in 2-dimensional coordinate systems. It can be used in all
kinds of 2D plotting and visualisation programs. As we made this widget
mainly for the CASE Cellular Automata project, we have included most of
its documentation here. You may of course use this widget freely for
whatever purpose you like.

We have left out the function documentation, because most of the drawing
functions in CAVisual are just "wrappers" for the X2Dview functions, and
are basically identical in usage.

@menu
* Compatibility::               
* X2DviewWidgetClass Features::  
* Availability::                
* Bugs (undocumented features)::  
@end menu

@node Compatibility, X2DviewWidgetClass Features, X2DviewWidgetClass Introduction, X2DviewWidgetClass Introduction
@subsection Compatibility
The X2Dview widget has been tested under X11 R5, R6 and a beta release
of R6.1. It is possible that it will work under R4 and lower, but this
is not tested. The double buffering routines are updated for the coming
R6.1 @emph{Xdbe} extension, and the can be compiled to use either these
routines or the older @emph{Xmbuf} extension.

The widget and the demo programs have been written on a Linux system
with XFree86 2.1, and has been compiled and tested under FreeBSD 2.1.0,
SunOS 5.5 (Solaris) and SunOS 4.1.4

@node X2DviewWidgetClass Features, Availability, Compatibility, X2DviewWidgetClass Introduction
@subsection X2DviewWidgetClassFeatures
@noindent
The widget has the following features:
@itemize @bullet
  @item Primitive drawing functions (line, point, circle).
  @item Complex drawing functions (Polygon).
  @item Text drawing and font handling functions.
  @item Private or default colormap with <= 256 colors.
  @item Loading/Saving of colormap to disk.
  @item Buffered point and line drawing functions for enhanced X11
    performance.
  @item Double-buffering for smooth animation.
  @item Unlimited (well, almost :-) zoom. 
  @item Callback-routines for mouse click events.
  @item 2D transformation routines (rotate, scale, shear, translate).
@end itemize

@node Availability, Bugs (undocumented features), X2DviewWidgetClass Features, X2DviewWidgetClass Introduction
@subsection Availability
@noindent
The X2Dview package can be fetched with anonymous ftp at one of the
following sites:

@itemize @bullet
@item @code{ftp.iu.hioslo.no/pub/X2Dview-0.9b.tar.gz}
@item @code{ftp.sn.no/pub/user/thomasen/X2Dview-0.9b.tar.gz}
@end itemize

@node Bugs (undocumented features),  , Availability, X2DviewWidgetClass Introduction
@subsection Bugs (undocumented features)
@noindent
Probably lots! But here are at least the ones we know about:

@itemize @bullet
  @item Zooming while running a double-buffered animation causes
    flicker. 
  @item Remains of the prevous buffer contents sometimes show when
    starting a zoom.
@end itemize

After this first public release we will try to keep the programming
interface unchanged, and only add new functions as we see fit.

@node Resources,  , X2DviewWidgetClass Introduction, X2DviewWidgetClass
@section Resources
The resources in the table below can be set through the X Resource manager
(Through a resource file, the command line or X Toolkit founctions).

@iftex
@tex
\font\tablefont=cmtt10
\hskip 12pt
\vbox{\offinterlineskip
\halign{\strut \vrule \quad {\tablefont #} \quad 
        & \vrule \hfil \quad {\tablefont #} \hfil 
        & \vrule \hfil \quad {\tablefont #} \hfil 
        & \quad \vrule \hfil \quad {\tablefont #}\quad\hfil\vrule\cr
\noalign{\hrule}
{\rm \bf Name} & {\rm \bf Class} & {\rm \bf RepType} & {\rm \bf Default Value}\cr
\noalign{\hrule}
background          & Background        & Pixel       & XtDefaultBackground\cr
border              & BorderColor       & Pixel       & XtDefaultForeground\cr
borderWidth         & BorderWidth       & Dimension   & 1\cr
destroyCallback     & Callback          & Pointer     & NULL\cr
height              & Height            & Dimension   & 0\cr
mappedWhenManaged   & MappedWhenManaged & Boolean     & True\cr
sensitive           & Sensitive         & Boolean     & True\cr
width               & Width             & Dimension   & 0\cr
x                   & Position          & Position    & 0\cr
y                   & Position          & Position    & 0\cr
x\_min               & X\_min             & double      & -2.0\cr
x\_max               & X\_max             & double      & 2.0\cr
y\_min               & Y\_min             & double      & -2.0\cr
y\_max               & Y\_max             & double      & 2.0\cr
def\_x\_min           & Def\_x\_min         & double      & 0\cr
def\_x\_max           & Def\_x\_max         & double      & 0\cr
def\_y\_min           & Def\_y\_min         & double      & 0\cr
def\_y\_max           & Def\_y\_max         & double      & 0\cr
pixx                & Pixx              & double      & 0\cr
pixy                & Pixy              & double      & 0\cr
zBoxLineStyle       & ZboxLineStyle     & GCValue     & LineOnOffDash\cr
zBoxLineWidth       & ZboxLineWidth     & int         & 1\cr
zBoxForeground      & ZboxForeground    & Pixel       & "Green"\cr
click               & Callback          & XtCallbackList & NULL\cr
dblClick            & Callback          & XtCallbackList & NULL\cr
viewportChanged     & Callback          & XtCallbackList & NULL\cr
\noalign{\hrule}
}}
@end tex
@end iftex

@menu
* Custom resources explained::  
@end menu

@node Custom resources explained,  , Resources, Resources
@subsection Custom resources explained
The first 10 resources in the resource table are standard Xt resources
which are thoroughly explained in most X programming books, and are
therefore not explained here.

Many of these resources contain floating-point values. Setting these
resources through an argument list can be a bit tricky, but take a look
at the examples, and you'll see how it should be done. 

@menu
* x_min::                       
* def_x_min::                   
* pixx::                        
* zBoxLineStyle::               
* zBoxLineWidth::               
* zBoxForeground::              
* viewportChanged::             
* click::                       
* rtClick::                     
@end menu

@node x_min, def_x_min, Custom resources explained, Custom resources explained
@subsubsection x_min, x_max, y_min, y_max
@iftex
@tex
These resources determine the initial coordinate system boundaries in
x- and y-direction. The default coordinate system is $x \in [-2,
2]$ and $y \in [-2, 2]$.
@end tex
@end iftex

@ifinfo
These resources determine the initial coordinate system boundaries in
x- and y-direction. The default coordinate system is with x in [-2, 2]
and y in [-2, 2].
@end ifinfo

These values can also be set by using the convenience routine @code{X2DsetViewport()}.
@sp 1
@noindent
@b{Example:}
@smallexample

drawbox = XtVaCreateManagedWidget("drawbox",X2DviewWidgetClass,form,
                                  XtVaTypedArg, XtNx_min, XtRString, 
                                  "-5.5", sizeof("-5.5") + 1,
                                  XtVaTypedArg, XtNx_max, XtRString, 
                                  "5.5", sizeof("5.5") + 1,
                                  NULL);

@end smallexample
@iftex
@tex
This creates an X2Dview widget with $x @in [-5.5, 5.5]$ and $y @in
[-2.0, 2.0]$.
@end tex
@end iftex
@ifinfo
This creates an X2Dview widget with x in [-5.5, 5.5] and y in
[-2.0, 2.0].
@end ifinfo

@node def_x_min, pixx, x_min, Custom resources explained
@subsubsection def_x_min, def_x_max, def_y_min, def_y_max
These resources specify the ``outer boundaries'' of the coordinate
system. When you zoom out the coordinate system will take these
values. 

You can also set these values with the convenience routine
@code{X2DsetOuterLimits()}. 

@node pixx, zBoxLineStyle, def_x_min, Custom resources explained
@subsubsection pixx, pixy
Pixels pr. unit in x- and y-direction. These values are Read-only, and
can be used to calculate the pixel coordinates of a pint given in
logical coordinates.


@node zBoxLineStyle, zBoxLineWidth, pixx, Custom resources explained
@subsubsection zBoxLineStyle
This resource determines the line style of the zoom box. The default
value is @code{LineOnOffDash}. Possible values for this resource
are:

@itemize @bullet
  @item @code{LineOnOffDash}: Dashed line alternating between foreground color and transparent.
  @item @code{LineDoubleDash}: Dashed line alternating between foreground and
    background color.
  @item @code{LineSolid}: Solid line with foreground color.
@end itemize
  
@node zBoxLineWidth, zBoxForeground, zBoxLineStyle, Custom resources explained
@subsubsection zBoxLineWidth
This resource determines the line width in pixels of the zoom box.
 
@node zBoxForeground, viewportChanged, zBoxLineWidth, Custom resources explained
@subsubsection zBoxForeground
This resource determines the foreground color of the zoom box. It can
be given as an X color name string, e.g. ``SteelBlue''.

@node viewportChanged, click, zBoxForeground, Custom resources explained
@subsubsection viewportChanged
This resource is a pointer to a callback function which is run each
time the coordinate system values are changeds, for example by
zooming. This could typically be a redraw routine.
@sp 1
@noindent
@b{Example:}

@smallexample
vp = XtVaCreateManagedWidget("drawbox",X2DviewWidgetClass,parent,
                              NULL);
XtAddCallback(vp, XtNviewportChanged, (XtPointer)Redraw, 
              (XtPointer)vp);

...

void Redraw(Widget w, XtPointer data, XEvent *event)
{
 Widget vp = (Widget)data;

 X2DsetForegroundRGB(vp, 200, 100, 100);
 X2DdrawLine(vp, -300, 300, 300, -300); 
 X2DdrawPolygon(vp, 10, StarX, StarY);
 X2DdrawCircle(vp, 0, 0, 135); 
}
@end smallexample

@node click, rtClick, viewportChanged, Custom resources explained
@subsubsection click
This is a callback function which is called when the left mouse button
is clicked in the coordinate system. It sends the logical
coordinates of the mouse pointer as call data.
@sp 1
@noindent
@b{Example:}
@smallexample
vp = XtVaCreateManagedWidget("drawbox",X2DviewWidgetClass,parent,
                              NULL);
XtAddCallback(vp, XtNselect, (XtPointer)DoubleClick, NULL);

...

void DoubleClick(Widget w, XtPointer data, XtPointer n_pos)
{
 Widget vp = (Widget)w;
 X2DPoint *pos = (X2DPoint*)n_pos;

 printf("You clicked at (%lf, %lf)\n", pos->x, pos->y);
}
@end smallexample

@node rtClick,  , click, Custom resources explained
@subsubsection rtClick
This is a callback function which is called when the left mouse button
is double-clicked in the coordinate system. It sends the logical
coordinates of the mouse pointer as call data.

@c **********************************************************************
@c BIBIOGRAPHY
@c **********************************************************************

@node bibliography, Variable and function Index, X2DviewWidgetClass, Top
@appendix References

@enumerate

@item 
R. Feynman, @emph{Simulating physics with computers}, Int. J. Theor. Phys. Vol @b{21},
467, 1982

@item
B.P. Zeigler, @emph{Discrete event models for cell space simulation}, 
Int. J. Theor. Phys. Vol @b{21}, 573, 1982

@item
M. Minksky, @emph{Cellular Vacuum}, Int. J. Theor. Phys. Vol @b{21},
537, 1982

@item
K. Zuse, @emph{The computing universe}, Int. J. Theor. Phys. Vol @b{21},
589, 1982

@item
A. Schadscheider and M. Schreckenberg, @emph{Cellular automata for traffic flow},
cond-mat/9511037, LANL database.

@item
E. Dan Dahlberg and J.G. Zhu, @emph{Micromagnetic Microscopy and Modelling},
Physics Today April 1995, 34.

@item
The Argus project, http://www.geog.le.ac.uk/argus/About/aboutargus.html  

@item
The Virtual Laboratory, http://www.tp.umu.se/TIPTOP/VLAB/about.html

@item
X windows: documentation, volumes 0 - 10, O'Reilly and Associates.

@item T. Tokihiro, D. Takahashi, J. Matsukidaira and J. Satsuma, Physical
review Letters 29, 3247 (1996)

@end enumerate

@c **********************************************************************
@c INDEX
@c **********************************************************************
@iftex
@headings off
@everyheading @| @thischapter  @| @thispage
@end iftex

@node Variable and function Index,  , bibliography, Top
@unnumbered Function Index

@printindex fn

@shortcontents
@contents

@bye



